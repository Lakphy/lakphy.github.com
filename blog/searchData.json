[{"title":"一段逆天的js代码","url":"/blog/2022/08/01/一段逆天的js代码/","content":"\n从学长那里看到一段逆天的 js 代码，代码不长，但考察了很多知识点。\n\n上代码：\n\n```js\nconst p = Promise.resolve();\nlet sum = 0;\nasync function add(i, j) {\n  sum += await (i + j);\n}\nsetTimeout(() => {\n  console.log(sum);\n});\nfor (let i = j = 0; i < 3; i++, j++) {\n  p.then(() => {\n    add(i, j);\n  });\n}\n```\n\n这段代码考察了很多知识点，哪怕一个知识点答错，都答不出正确答案\n\n## 单步调试\n\n不懂这段代码的话，我们可以先在浏览器 devtool 中调试一下：\n\n![devtool调试](1.gif)\n\n## 逐步解释\n\n接下来我来按语句执行顺序解释整个执行过程：\n\n> 在开始之前我们要先明确一个事情：JS 是单线程的\n\n🔴 首先声明语句暂时不解释\n\n🔴 首先看`setTimeout`这里，这条语句很简单，字面意思就是 0 秒后输出`sum`，但由于 js 单线程的特性，这条语句的意思就是“当前任务结束后输出`sum`”，也就是把要执行的代码暂时挂起。\n\n🔴 接下来看到`for`，重点放在括号内的声明`let i = j = 0`，请注意这个语句并不是声明了“两个作用域在 for 循环内的变量”。\n\n这条语句做了两件事：\n\n- 将`0`赋给`j`，但因为`j`未声明，所以自动在全局（Global）声明了一个`j`变量。\n- 用`let`声明了一个作用域在 for 循环内的变量，并将表达式`j = 0`的返回值（即`0`）赋给`i`\n\n在 devtool 的调试中可以很明显的看到`i`和`j`的声明位置不同\n\n所以说这里的`i`是局部变量，for 循环结束即销毁，而`j`却是全局变量\n\n🔴 接下来看 for 循环内的语句`p.then()`\n\n先不管 then 里面干了啥，先看这个`p.then()`有什么目的。看看前面的声明语句\n\n```js\nconst p = Promise.resolve();\n```\n\n那拼起来就是`Promise.resolve().then()`，熟悉异步的同学就能看出来，这段代码的意思和之前`setTimeout`那里一样，就是将 then 里面代码暂时挂起，待当前任务结束后执行。\n\n> 这里还需注意一个问题：**执行时机**\n>\n> `Promise`会比`setTimeout`更先执行，[详情](https://juejin.cn/post/6844903607276437517)\n\n🔴 再看 then 里面的代码`() => { add(i, j); }`，就是调用一个`add()`函数，干了什么先不考虑\n\n🔴 那合起来我们就可以理解整个 for 循环做了什么事：\n\n循环了三次，挂起了三个`() => { add(i, j); }`。\n\n由于`add()`是外部的一个函数，而`i`的作用域仅在 for 循环内，这里就产生了一个闭包，而在 同一位置 不同方式 声明的`j`，被默认定义在了全局（Global），因此不会出现闭包。\n\n因此我们可以列一个表记录 for 循环结束后代码所挂起的三个任务以及他们闭包内可以获取到的参数：\n\n（因为三个任务都不是立即执行，所以执行时获取到的 j 一定为代码执行时 j 的值，即 for 循环结束后的终止）\n\n| 顺序 | 任务                   | i   | j           |\n| ---- | ---------------------- | --- | ----------- |\n| 1    | `() => { add(i, j); }` | 0   | 3（Global） |\n| 2    | `() => { add(i, j); }` | 1   | 3（Global） |\n| 3    | `() => { add(i, j); }` | 2   | 3（Global） |\n\n循环结束后：\n\n```js\ni = undefined;\nj = 3;\n```\n\n🔴 接下来代码运行结束，开始执行之前挂起的任务\n\n之前说过`Promise`会比`setTimeout`更先执行，所以挂起任务的执行顺序为：\n\n| 顺序 | 任务                          | 闭包变量 | 全局变量 |\n| ---- | ----------------------------- | -------- | -------- |\n| 1    | `() => { add(i, j); }`        | i = 0    | j        |\n| 2    | `() => { add(i, j); }`        | i = 1    | j        |\n| 3    | `() => { add(i, j); }`        | i = 2    | j        |\n| 4    | `() => { console.log(sum); }` | 🈚️      | sum      |\n\n🔴 依次用不同“参数”执行三个`() => { add(i, j); }`\n\n观察`add()`函数代码\n\n```js\nasync function add(i, j) {\n  sum += await (i + j);\n}\n```\n\n没错这又是一个异步的代码！\n\n由于`await`的特性，当执行到`await`时，此段任务的剩余代码 包括`await`所在语句会被一个`Promise`包起来。由于这里`await`后面表达式返回值不是一个 Promise，所以这里的意思是：\n\n> 此段任务的剩余代码 包括`await`所在语句会被`Promise`包起来并且挂起，等待其他优先级更高的任务执行完再执行\n\n另外这里新建的任务优先级是和之前`Promise`挂起的任务相同的，所以比`setTimeout`更先执行，并且与之前的`Promise`挂起的任务队列一起依次执行\n\n同时这里还有一个考点 ⚠️：\n\n> `await`语句及其后面代码被包进`Promise`时，会为这些代码用到的外部变量产生一个闭包\n\n🔴 我们来重新梳理一下任务列表：\n\n当第一个`() => { add(i, j); }`执行后：\n\n| 是否完成 | 顺序 | 任务                              | 闭包变量        | 全局变量 |\n| -------- | ---- | --------------------------------- | --------------- | -------- |\n| True     | 1    | `() => { add(i, j); }`            | i = 0;          | j        |\n| False    | 2    | `() => { add(i, j); }`            | i = 1;          | j        |\n| False    | 3    | `() => { add(i, j); }`            | i = 2;          | j        |\n| False    | 4    | `() => { sum += await (i + j); }` | i = 0; sum = 0; | j        |\n| False    | 5    | `() => { console.log(sum); }`     | 🈚️             | sum      |\n\n那么以此类推，当我们的`() => { add(i, j); }`任务全部执行完毕后\n\n| 是否完成 | 顺序 | 任务                              | 闭包变量        | 全局变量 |\n| -------- | ---- | --------------------------------- | --------------- | -------- |\n| True     | 1    | `() => { add(i, j); }`            | i = 0;          | j        |\n| True     | 2    | `() => { add(i, j); }`            | i = 1;          | j        |\n| True     | 3    | `() => { add(i, j); }`            | i = 2;          | j        |\n| False    | 4    | `() => { sum += await (i + j); }` | i = 0; sum = 0; | j        |\n| False    | 5    | `() => { sum += await (i + j); }` | i = 1; sum = 0; | j        |\n| False    | 6    | `() => { sum += await (i + j); }` | i = 2; sum = 0; | j        |\n| False    | 7    | `() => { console.log(sum); }`     | 🈚️             | sum      |\n\n🔴 接下来依次执行`() => { sum += await (i + j); }`任务\n\n| 顺序 | 任务                              | 闭包变量        | 全局变量 | 执行后 sum 的值 |\n| ---- | --------------------------------- | --------------- | -------- | --------------- |\n| 4    | `() => { sum += await (i + j); }` | i = 0; sum = 0; | j        | 3               |\n| 5    | `() => { sum += await (i + j); }` | i = 1; sum = 0; | j        | 4               |\n| 6    | `() => { sum += await (i + j); }` | i = 2; sum = 0; | j        | 5               |\n\n这里终于不用考虑异步了，依次执行就行\n\n🔴 最后一个终于轮到`() => { console.log(sum); }`了，直接输出全局的`sum = 5`\n\n## 坑点梳理\n\n最后让我们梳理一下坑点\n\n- **执行时机**：`Promise.resolve().then()`和`setTimeout(fn,0)`都是立即执行，且都需要等待当前任务执行完后再执行，但是`Promise`的优先级更高，更先执行。另外`await/async`语句执行优先级和`Promise`相同。在任务执行时，同类型任务，也是按先创建先执行顺序执行。\n- **语句理解**：`let i = j = 0`语句在解释时，`let`应从左往右解释，`=`应从右往左解释（《You Don't Know JavaScript》第一章便有讲解），也就是说只声明了局部的`i`而未声明`j`，所以`j`被默认安排在了全局。\n- **闭包问题**：闭包这个问题算是老生常谈了，不做解释，多练练就会了。但是`await`这里会有隐藏的闭包要注意，`await`语句及其后面代码被包进`Promise`时，会为这些代码用到的外部变量产生一个闭包\n","tags":["js"]},{"title":"Redux学习笔记（React）","url":"/blog/2022/07/22/Redux学习笔记/","content":"\n最近在研究 Redux。看了中文文档感觉翻不太行，所以我在读英文文档，但由于我英文水平不太行，本文将会以中文为主展现，主要作为个人记忆用。\n\n感觉 Redux 这个入门文档有点杂，掺入了官方推荐工具`Redux-Toolkit`和`Redux-React`的内容。本篇介绍的 Redux 是借用这些工具使用的。\n\n# 基本配置\n\n## 创建`store`\n\nRedux 的 store 由 RTK（Redux Toolkit）的 `configureStore` api 创建。\n\n文档建议此段代码位置在 `/src/app/store.js` 中\n\n```js\nimport { configureStore } from \"@reduxjs/toolkit\";\nimport counterReducer from \"../features/counter/counterSlice\";\n\nexport default configureStore({\n  reducer: {\n    counter: counterReducer,\n  },\n});\n```\n\n从文档中的代码可以看出`configureStore`用法：\n\n- 输入 一个对象\n  - reducer(object)\n    - 切片名:(createSlice()创建的切片.reducer)\n- 输出 一个 store 对象\n\n其中 store 对象会被`export default`，并且 store 对象**只能用于**`Provider`中，即`index.js`中的`<Provider store={store}>`\n\n一个 React App 建议（或者说 应当）只有一个 store\n\n## 用`Provider`覆盖 React 根结点\n\n将 React 原本的`<App />`修改为：\n\n```jsx\n<Provider store={store}>\n  <App />\n</Provider>\n```\n\n在 React App 的入口文件`index.js`中使用由`Redux-React`提供的`Provider`将根节点覆盖住，并传入 store\n\n## 创建 Redux 切片\n\n创建一个 Redux 切片即为在 Redux store 树 🌲 创建一个分支\n\n文档将其写在`/src/feature/counter/counterSlice.js`中\n\n### createSlice()\n\n首先使用 React Toolkit 提供的`createSlice()`创建一个 Redux 切片\n\n```js\nexport const counterSlice = createSlice({\n  name: \"counter\",\n  initialState: {\n    value: 0,\n  },\n  reducers: {\n    increment: (state) => {\n      // Redux Toolkit allows us to write \"mutating\" logic in reducers. It\n      // doesn't actually mutate the state because it uses the immer library,\n      // which detects changes to a \"draft state\" and produces a brand new\n      // immutable state based off those changes\n      state.value += 1;\n    },\n    decrement: (state) => {\n      state.value -= 1;\n    },\n    incrementByAmount: (state, action) => {\n      state.value += action.payload;\n    },\n    postAdded: {\n      reducer(state, action) {\n        state.push(action.payload);\n      },\n      prepare(title, content) {\n        return {\n          payload: {\n            id: nanoid(),\n            title,\n            content,\n          },\n        };\n      },\n    },\n  },\n});\n```\n\n由这段代码可以看出`createSlice`用法：\n\n- 输入 一个对象\n  - name:切片名称\n  - initialState 初始值，文档建议为对象形式\n  - reducers 一个对象，包含处理更改的 reducer\n    - reducer 名称:reducer 函数\n      - 函数输入\n        - state：当前切片值\n        - action：包含 Redux dispatch 传入的原始 [Action 对象](https://redux.js.org/tutorials/essentials/part-1-overview-concepts/#actions)，当使用 RTK 自动生成的[Action Creator](https://redux.js.org/tutorials/essentials/part-1-overview-concepts/#action-creators)进行 dispatch 时，[Action Creator](https://redux.js.org/tutorials/essentials/part-1-overview-concepts/#action-creators)函数的参数位于`action.payload`位置（同时这也是官方推荐的[Action 对象](https://redux.js.org/tutorials/essentials/part-1-overview-concepts/#actions)的标准写法）\n      - 函数特性\n        - 在 Redux 中，reducer 函数应当为**纯函数**，因为我注意到英文文档中并没有说过他是纯函数，只是在每次提到这个问题是列举一遍其特点，这里做一下摘抄\n          > reducers **must** always follow some special rules:\n          >\n          > - They should only calculate the new state value based on the state and action arguments\n          > - They are not allowed to modify the existing state. Instead, they must make immutable updates, by copying the existing state and making changes to the copied values.\n          > - They must not do any asynchronous logic or other \"side effects\"\n          >\n          > why are these rules important?\n          >\n          > - One of the goals of Redux is to make your code predictable. When a function's output is only calculated from the input arguments, it's easier to understand how that code works, and to test it.\n          > - On the other hand, if a function depends on variables outside itself, or behaves randomly, you never know what will happen when you run it.\n          > - If a function modifies other values, including its arguments, that can change the way the application works unexpectedly. This can be a common source of bugs, such as \"I updated my state, but now my UI isn't updating when it should!\"\n          > - Some of the Redux DevTools capabilities depend on having your reducers follow these rules correctly.\n        - 尽管文档反复强调**immutable**，即不更改行参，但是由于 RTK 使用了[immerjs](https://github.com/immerjs/immer)辅助，你也可以在 RTK 的 reducer 中使用 mutating 的代码，但是请注意**只能在 RTK 的 reducer 中这么写！！！**\n          > 引用原文\n          > 🔥WARNING\n          > Remember: **reducer functions must always create new state values immutably, by making copies!** It's safe to call mutating functions like `Array.push()` or modify object fields like `state.someField = someValue` inside of `createSlice()`, because it converts those mutations into safe immutable updates internally using the Immer library, but **don't try to mutate any data outside of `createSlice`!**\n    - 也可以在 reducer 名后传入一个对象`{reducer, prepare}`\n      - `prepare`函数，参数可以自定义，但与 reducer 不同的是我们可以将 reducer 禁止的代码（异步、随机、副作用等）写在`prepare`函数里。使用了`prepare`函数后，在其生成的[Action Creator](https://redux.js.org/tutorials/essentials/part-1-overview-concepts/#action-creators)中可以直接使用我们自定义的`prepare`函数的参数调用。\n        - 参数：自定义\n        - 返回值：一个无需`type`字段的 Action 对象，即`{payload:{}}`，也允许添加`meta`、`error`字段\n          - `payload`：Action 对象的`payload`\n          - `meta`：可用于向 action 添加额外的描述性值\n          - `error`：该字段应该是一个布尔值，指示此 action 是否表示某种错误\n      - `reducer`函数本身，与之前说的要求一样\n- 返回值 返回一个初始化好的 Redux 切片对象，我们可以从这个对象中获得我们有用的东西（见下文）\n\n### 获取[Action Creator](https://redux.js.org/tutorials/essentials/part-1-overview-concepts/#action-creators)\n\n```js\nexport const { increment, decrement, incrementByAmount } = counterSlice.actions;\n```\n\n此段代码用于从 Redux 切片中获取[Action Creator](https://redux.js.org/tutorials/essentials/part-1-overview-concepts/#action-creators)函数\n\n### 导出切片的[Selectors](https://redux.js.org/tutorials/essentials/part-1-overview-concepts#selectors)\n\n如果我们可以直接获取到 Redux store 对象，可以直接使用`store.getState()`获取整个 store 树的存储，[Selectors](https://redux.js.org/tutorials/essentials/part-1-overview-concepts#selectors)就是负责从整个 store 数中拿到我们切片数据的\n\n或许我们可以直接把它（Selector）写成这样：\n\n```js\nexport const selectCounterValue = (state) => state.counter;\n```\n\n就是一个非常简单的把 store 树上一部分取出来的工具，可以在这里写好然后导出，也可以用的时候现写。\n\n> 刚说到“如果我们可以直接获取到 Redux store 对象”，这是一种理想情况，而 RTK 不允许我们随意引用和使用 store 对象，~~而且这么做也不优雅~~，这时候会需要用到 Redux-React 提供的`useSelector`工具，将会在后文解释\n\n### 导出 reducer\n\n我们之前初始化 Redux 切片时传入的 Reducer 是一个一个独立的，还要经过 RTK 的合并和处理（其中有一项可能和之前说的 immerjs 有关），才能用于 Redux store，可以通过以下代码将 RTK 处理过的 reducer 导出\n\n```js\nexport default counterSlice.reducer;\n```\n\n## 在 React Component 中应用 Redux\n\n这部分内容主要由`Redux-React`提供，毕竟 Redux 并不是局限于某个 js 框架的状态管理工具，他是一个非常开放的工具。\n\n### 获取 Redux store 数据\n\n`Redux-React`提供了`useSelector`钩子用来获取 Redux store 中的数据，使用方法如下\n\n引入\n\n```js\nimport { useSelector } from \"react-redux\";\n```\n\n在 React Component 中调用\n\n```js\nconst count = useSelector(selectCount);\n```\n\n其中`selectCount`即为[上文中导出的 Selector](#导出切片的Selectors)。\n\n当然也可以写为行内的 Selector：\n\n```js\nconst count = useSelector((state) => state.count);\n```\n\n这样可以得到 Selector 筛选后的 store 数据，并且得益于`Redux-React`对 React 的单独适配，当筛选后的 store 数据变化时，对应组件也会进行重新渲染。\n\n### dispatch 更改\n\n由于 Redux 禁止直接获取 store，`Redux-React`提供了`useDispatch`钩子用来获取 `dispatch` 函数\n\n引入\n\n```js\nimport { useSelector } from \"react-redux\";\n```\n\n在 React Component 中调用\n\n```js\nconst dispatch = useDispatch();\n```\n\n然后便可以直接使用`dispatch`函数去触发更改了，与`store.dispatch`用法相同，可以传入[Action Creator](https://redux.js.org/tutorials/essentials/part-1-overview-concepts/#action-creators)（包括 RTK 生成的 Action Creator），也可以传入一个简单的 action 对象，下面这两种方法都是可以的，传入 payload 的类型也没有限制。\n\n```js\ndispatch({ type: \"counter/incrementByAmount\", payload: 2 });\ndispatch(incrementByAmount(2));\n```\n\n> ⚠️ 警告\n> Redux actions and state should only contain plain JS values like objects, arrays, and primitives. Don't put class instances, functions, or other non-serializable _(不可序列化)_ values into Redux!.\n\n# 使用 Thunk 函数\n\nthunk 函数通常写在 slice 文件内，（与`createSlice`同文件），这样可以便于寻找代码。\n\n## 使用简单的 Thunk\n\nthunk 是一种特定类型的 Redux 函数，可以包含异步逻辑。Thunk 是使用两个函数编写的：\n\n- 内部 thunk 函数，它以 `dispatch` 和 `getState` 作为参数\n- 外部 thunk creator 函数，它创建并返回 thunk 函数\n\n例如在[Redux Demo](https://codesandbox.io/embed/github/reduxjs/redux-essentials-example-app/tree/master/)中有一段异步 dispatch 的例子，这个例子写在`/src/feature/counter/counterSlice.js`中\n\n```js\nexport const incrementAsync = (amount) => (dispatch, getState) => {\n  setTimeout(() => {\n    dispatch(incrementByAmount(amount));\n  }, 1000);\n};\n```\n\nthunk 函数可以这样 `dispatch`\n\n```js\ndispatch(incrementAsync(5));\n```\n\n我们可以将这个函数提高一下代码可读性来看\n\n```js\nexport const incrementAsync = (amount) => {\n  return (dispatch, getState) => {\n    setTimeout(() => {\n      dispatch(incrementByAmount(amount));\n    }, 1000);\n  };\n};\n```\n\n代入至 `dispatch`\n\n```js\ndispatch((dispatch, getState) => {\n  setTimeout(() => {\n    dispatch(incrementByAmount(5));\n  }, 1000);\n});\n```\n\n也就是相当于向`dispatch`传入一个函数 A，参数为`dispatch`和`getState`函数，在函数 A 内实现异步逻辑之后再去`dispatch`。\n\n> 使用 thunk 需要在创建时将 `redux-thunk` middleware（一种 Redux 插件）添加到 Redux store 中。幸运的是，RTK 的 configureStore 函数已经自动为我们配置好了，所以我们可以继续在这里使用 thunk。\n\n另外再提供一个改自文档的网络请求的例子\n\n```js\nconst fetchUserById = (userId) => {\n  return async (dispatch, getState) => {\n    try {\n      const user = await fetchUser(userId);\n      dispatch(userLoaded(user));\n    } catch (err) {\n      // do sth\n    }\n  };\n};\n```\n\n可以看到外部 thunk creator 函数的作用是为了将我们的参数传入 thunk 内部函数，并且还能与 Action Creator 形式保持一致\n\n# 其他功能\n\n## @reduxjs/toolkit\n\n### `nanoid`\n\n基于[nanoid/nonsecure](https://github.com/ai/nanoid)，用于生成一个随机 id 字符串，在 Redux 内部主要用于管理`createAsyncThunk`的异步请求 id，也可以用于其他用途。\n\n```js\nimport { nanoid } from \"@reduxjs/toolkit\";\n\nconsole.log(nanoid());\n// 'dgPXxUz_6fWIQBD8XmiSy'\n```\n\n# 未完待续\n","tags":["Redux","React"]},{"title":"《编程之美》读书记录（一）","url":"/blog/2022/07/20/《编程之美》读书记录（一）/","content":"\n作为一个程序员，我个人对微软非常向往的，不论是技术环境、工作待遇等等方面看，而且看到一个又一个学长去微软实习，心里很是羡慕。\n\n记得去年年底微软招聘微信公众号发布了“[微软 2022 暑期实习研发提前批正式启动](https://mp.weixin.qq.com/s/nAibjhSMvA6zfxcG32Sx6w)”的文章，实在是让我感到很震撼，太卷了吧，暑期实习要提前半年开始面试，那我岂不是提前一年就要开始准备啊，一想到这里就感觉到强烈的紧迫感。\n\n前几天接触到了一个刚从 MS 北京毕业的高中校友，我顺便就问了一些关于去 MS 需要注意的事情，他就给我推荐了《编程之美》这本书。\n\n为了督促学习，尽管找到了 pdf 资源，我还是买了纸质版本，并且希望把今后在博客上记录一些读书时遇到的值得记忆的问题和知识点。\n\n![book](s34075059.jpeg)\n\n---\n\n很明显这本书应该多数是算法题，看了一眼应该是 C 语言。作者也有写到 MS 很重视 C 语言基础，看来我要重新拾起将近四年没有碰的 C 语言和算法了（自 18 年 Noip 落榜后，我更专注于一些脚本语言了，可能因为他们可以更快速地给我带来快乐）\n\n我其实是本来就有重拾算法的计划的，只是不知道怎么重拾，买了一本紫皮书《算法竞赛入门经典》，但又感觉可能不太适合，毕竟我重拾算法也不大可能去打 ACM，看紫皮书完全是大材小用。\n\n我会在阅读过程中看到什么想记的，就记下来了，可能我的记录毫无规律，敬请谅解。\n\n希望这本书能够帮助我我重拾算法，带我走进 MS 🙏\n\n下面就是正文了，您有时候看到文章可能是没写完的，毕竟我目前除了学业外还需要承担很多前端项目开发工作和社团管理工作，另一边我还在读纯英文的 Redux 文档，我会尽可能高频率地去更新，更新进度即代表我的阅读进度\n\n---\n\n# 面试杂谈的一些记录\n\n## 随便记点\n\n- 面试前去多多了解对方企业的产品和业务，尤其是对自己要去的组要尽可能多地了解\n- > 对于微软的工程师来说，C 语言是基本功。\n- [微软亚洲研究院官网](https://www.msra.cn)\n\n## 下水道的井盖为什么是圆的？\n\n（这是一个 PM 问题）\n\nemmmm 这题就是考察思维能力，没有正确答案，主要是看你思考的过程，可以看看知乎上的各种答案：[井盖为什么是圆的 - 知乎](https://www.zhihu.com/question/19678960)\n\n## 三盏灯问题\n\n（这是一个 PM 问题）\n\n> 房间里有三盏灯，屋外有三个开关，分别控制这三盏灯，只有进入房间，才能看到哪一个电灯是亮的。请问如何只进入房间一次，就能指明哪一个开关控制哪一个灯？\n\n### 答案一\n\n开 A 开关 10 分钟，关掉，再开 B 开关，进屋，两者的是 B，热的是 A，剩下一个是 C\n\n### 待补充\n\n# 第一章-游戏之乐\n\n## 1.1-让 CPU 占用率听你指挥\n","tags":["《编程之美》"]},{"title":"打印了一个2021 Github Contributions","url":"/blog/2022/07/20/打印了一个2021-Github-Contributions/","content":"\n先看实物图：\n![Github Contributions](/blog/imgs/670ADD2B56444B2FDB90C54283180CF4.jpg)\n\n这是一个 Github2021 年的年度 Contributions 小绿格的 3D 打印版本\n\n![screenshot](1.png)\n\n如图是我 2021 年的“2D”版本 Github Contributions，点击右下角文字即可展示酷炫的 3D 效果图\n\n![screenshot](2.png)\n\n还可以点击下载`stl`文件，然后 3D 打印出来\n\n这个产品的名字叫**Skyline**\n\n太酷炫了，应该没有一个程序员能抗拒这么酷的东西\n\n对于我来说，他不仅记录了我一年来的开发贡献，\n\n2021 年是我开始深入进行前端开发的第一年，\n\n我承认我之前没有深入前端开发是存在某些偏见，我片面以为前端开发就是三大件，没有什么东西\n\n> （当然这个理解也让我在之前就积累了充足的切图经验）\n\n后来我才逐渐发现，在某种意义上讲，三大件可能只是运营同学的工具，而深入前端开发大有乾坤。\n\n对着这个这个立体图，我仿佛看着我做的每一个项目，仿佛看到了每一个开发调试熬夜上线的夜晚，甚至指着每一个小山峰我都可以说出那是哪个项目（当然因为保密原因我这里就不细嗦了）\n\n就像我在 2021 年度总结上面写的一样，一个一个项目，也是象征着我水平逐渐上涨，前端学习的逐渐深入。\n\n其实 Github 的这个小玩意很早就上线了，但我一直忍住没打，主要是想 22 年努力做一个更好看的图再去打印。\n\n最近实在忍不住了，毕竟是第一年深入前端，还是很有纪念意义的，虽然 22 年已经过半了，但还是有必要去打印一下的\n\n我的这些 Contributions 质量倒是可以保证，而且都是实际上线的项目开发的成果，并且都有上万的用户量，对我个人来讲，项目经历是够用了，\n\n但反思一下，\n\n这一年我除了做项目，似乎什么都没做...\n\n21 年开始，我的博客逐渐不更新了，我的 Contributions 里几乎没有更新博客相关的\n\n也就是相当于除了项目必须技术，我几乎没学什么技术，我觉得对我来说影响是非常大的，\n\n所以这次重新拾起博客也是想在未来多学习一些技术，提升自己，并通过博客督促自己\n\n另外我也建立了前端开发相关 ~~但不限于前端开发~~ 的 Telegram 频道，欢迎订阅：\n[https://t.me/lakphyFE](https://t.me/lakphyFE)\n\n> 另外`Skyline`的 url 似乎有某种规律，应该可以用来看任意时间任意人的 3D 图，用心了\n\nEnd...\n![End](SKY_20220522_012554_.jpg)\n","tags":["Github","打工人","杂谈"]},{"title":"记一次Hexo迁移踩坑","url":"/blog/2022/07/19/记一次Hexo迁移踩坑/","content":"\n又是将近一年没有更新博客了。。。\n前几天重装系统，因为之前博客是没有备份的，所以我就顺便把博客备份到 onedrive 上，准备在 Mac 上重新把它跑起来，然后这事就搁置下了。\n直到昨天才想起来 onedrive 上还有备份的博客，赶紧拿出来一看，`package.json`没备份，这下凉了。\n因为我这个博客应该是 20 年初年起的项目，年代久远，没`package.json`大概率难找了。\n于是我尝试用新版 Hexo 起项目，替换配置，结果出来一堆乱码，大概内容是这样：\n\n```\n{% extends '_layout.swig' %} {% import '_partials/index.swig' as template %} {% block content %}\n```\n\n首先因为配置文件和主题年代问题，我首先想到的是主题老了，我就看了眼我魔改主题的底包,[hexo-casper](https://github.com/xzhih/hexo-theme-casper)，结果 2 年前就停更了，这下寄了。\n所以我决定换一套主题，毕竟我博客源文件还在问题不大。\n搜了一圈，也就[butterfly](https://github.com/jerryc127/hexo-theme-butterfly)能看的下去，但是性能太差了，我 12g 的小米 10 Chrome 用着都掉帧，这是我最不能忍受的。\n没办法，我又回来看我这个陈年老博客。\n之前因为年代久远，我主观臆断了，没使用搜索引擎，这次我一搜报错，才知道问题所在\n万能的 Google 第一条就解决了我的问题：\n![google](截屏2022-07-1922.01.36.png)\n这里引用一下[原答案](https://stackoverflow.com/a/72195402/19579333)：\n\n> I got the issue and solved it by installing hexo-renderer-swig manually.\n>\n> ```\n> npm install hexo-renderer-swig\n> ```\n\n我尝试了一下，完美解决问题，应该是缺少某些组件造成的问题\n更让我震惊的是他的兼容性，我的主题是 2020 年初找的[hexo-casper](https://github.com/xzhih/hexo-theme-casper)，并且基于此进行了魔改，在新版 hexo 上竟然完美运行\n既然博客装回来了，今后一定多多更新！\n","tags":["踩坑记录","hexo"]},{"title":"你的第一个个人网站","url":"/blog/2021/10/01/你的第一个个人网站/","content":"\n# 你的第一个个人网站----Hexo\n\n## 建站概述\n\n看到网络上各式各样的网站，你是否有想过搭建一个属于自己的个人网站？你可以在自己的网站上，分享生活，交流学习，留下点点滴滴感动。如果你是一个程序员，或者想要未来成为程序员，作为一名“有灵魂”的程序员，拥有一个个人网站，那是必不可少的。我们先来介绍一下搭建一个网站需要什么技术。\n\n现在主流的网站都是前后端分离式开发。\n\n| 前端                             | 后端                                 |\n| -------------------------------- | ------------------------------------ |\n| 页面元素、资源，接口调用（HTTP） | 具体的实现逻辑、数据库，接口传递数据 |\n\n未来让自己的网站更加便捷\n\n### 前端技术\n\n前端基础技术包括 HTML、CSS、JavaScript 等\n\n随着深入学习，这些技术无法满足我们的需要，于是就有了 TypeScript、React、Vue 等技术\n\n### 博客框架\n\n并不是所有人都熟悉前端开发，于是就有了博客框架，帮助我们低成本构建一个自己的博客，帮助创作者更集中精力于博客内容本身，输出更多优质文章。\n\n博客分为静态博客和动态博客\n\n#### 静态博客\n\n静态博客：仅仅有前端静态页面组成（Web 三件套：Html+Css+Js）。\n\n- Hexo：https://hexo.io/zh-cn/\n\n  Hexo 是一款基于 Node.js 的静态博客框架。\n\n- Jekyll：https://www.jekyll.com.cn/\n\n  Jekyll 是一个基于 Ruby 环境的静态网站生成器\n\n- Hugo：https://www.gohugo.org/\n\n  Hugo 是由 Go 语言实现的静态网站生成器\n\n- VuePress：https://www.vuepress.cn/\n\n  Vue 驱动的静态网站生成器。\n\n#### 动态博客\n\n动态博客：前后端配合开发的博客，可以进行后台管理。\n\n- Wordpress：https://wordpress.org/\n\n  使用 PHP 语言+Mysql 开发的博客平台。亦可以作为 CMS 来使用。\n\n- 你可以选择自己造轮子：JavaScript + SpringBoot + Mysql。\n\n### Hexo 博客框架\n\n我们本节课将会介绍 Hexo 博客框架建造个人网站\n\nhttps://hexo.io\n\nHexo 博客框架有以下特点\n\n#### 静态博客\n\nHexo 可以将你的博客编译成静态的一个文件夹，直接将他部署在 web 服务器中即可直接使用，无需部署后端。可以部署在 Github Pages 等平台，部署成本低，适合零基础入门和学习。\n\n#### 生态强大\n\nHexo 是生态最强大的博客框架之一，他拥有上千款主题和拓展插件可以使用，可拓展性很强，开发方便\n\n#### 支持 MarkDown 语法\n\nHexo 支持 GitHub Flavored Markdown 的所有功能，可以创造更加丰富的内容\n\n## 准备工作\n\n### 安装 git\n\n#### git 是个啥？\n\n> **什么是 Git？**\n>\n> GIT，全称是分布式版本控制系统。其实对于初学者就可以把它简单理解成一个云端的代码仓库，把你写的代码上传到云端仓库。\n>\n> 程序猿的世界里，自由、共享是一个基本的共识。而**github**是世界上最大的同性交友网站代码仓库，很多项目和框架都被放在上面。而我们所使用的 Hexo 框架以及一些插件都是要从 github 上面调用的。Git 就是这个版本控制软件，对于初学者来说，git 用来安装和克隆这些项目到本地，并且将本地代码推送到云端。\n>\n> **关于 Github Pages**：用于远程部署，使博客可以在网络上进行访问。\n>\n> **使用 github pages 服务搭建博客的好处有：**\n>\n> 1. 全是静态文件，访问速度快；\n> 2. 免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；\n> 3. 可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于 github 的；\n> 4. 数据绝对安全，基于 github 的版本管理，想恢复到哪个历史版本都行；\n> 5. 博客内容可以轻松打包、转移、发布到其它平台；\n\n#### 安装\n\n[git 官网](https://git-scm.com/)\n\n### 安装 Node.js\n\n#### 关于 Node.js\n\n- Node.js 基本介绍：\n\n  Node.js 是一个 javascript 运行环境。它让 javascript 可以开发**后端**程序，实现几乎其他后端语言实现的所有功能，可以与 PHP、Java、Python、.NET、Ruby 等后端语言平起平坐。是一种较为简单、轻量和高效的后端服务实现方式。\n\n- 很多开源的项目后台都是在 Node.js 的运行环境下运行的，比如 Hexo 的静态博客生成系统。相当于 jave 和 jvm（java 运行环境）的关系。\n\n- 有相当成熟的社区文化和众多的开发者。\n\n- 在开发一个复杂的应用程序的时候，我们需要把各个功能拆分、封装到不同的文件，在需要的时候引用该文件。没人会写一个几万行代码的文件，这样在可读性、复用性和维护性上都很差，几乎所有的编程语言都有自己的模块组织方式，比如 Java 中的包、C#中的程序集等，node.js 使用模块和包来组织，其机制实现参照了 CommonJS 标准，虽未完全遵守，但差距不大，使用起来非常简单。\n\n#### 关于 npm\n\n- Npm（Node package management）即 node 的包管理器：\n\n- NPM 思路大概是这样的：\n\n  1. 买个服务器作为代码仓库（registry），在里面放所有需要被共享的代码\n\n  2. 发邮件通知 jQuery、Bootstrap、Underscore 作者使用 npm publish 把代码提交到 registry 上，分别取名 jquery、bootstrap 和 underscore（注意大小写）\n\n  3. 社区里的其他人如果想使用这些代码，就把 jquery、bootstrap 和 underscore 写到 package.json 里，然后运行 npm install ，npm 就会帮他们下载代码\n\n  4. 下载完的代码出现在 `node_modules` 目录里，可以随意使用了。\n\n     这些可以被使用的代码被叫做「包」（package），这就是 NPM 名字的由来：Node Package(包) Manager(管理器)。\n\n- Hexo 也是被放在 npm 仓库里的，所以我们通过 npm 进行下载安装操作。\n\n#### 安装\n\n[Node.js 官网](https://nodejs.org/zh-cn/download/)\n\n#### npm 换源\n\n由于某些我们懂得都懂的原因，在国内使用 npm 官方镜像源可能无法访问或者速度慢，所以我们需要将他切换到国内的镜像源，操作很简单，在 CMD 中输入以下命令即可将 npm 的镜像源切换到国内淘宝源。\n\n```bash\nnpm config set registry https://registry.npm.taobao.org\n```\n\n按回车后命令行没有任何输出即代表设置成功\n\n> 没有任何输出就是最好的结果\n\n##### 备用方法\n\n由于某些原因，npm 修改镜像源可能无法生效，或者说你不想改动你的 npm 配置。这时候提供了一个解决方案是在`npm`中安装`cnpm`，在 CMD 中输入以下命令：\n\n```bash\nnpm install -g cnpm --registry=https://registry.npm.taobao.org\n```\n\n按回车后出现了一些进度条和文字，我们无需在意，等待安装结束即可\n\n![image-20211001093444248](image-20211001093444248-1633066914648.png)\n\n这样我们就安装了`cnpm`，如果你安装了`cnpm`，只需要将后面用到的命令中的`npm`改为`cnmp`\n\n### Visual Studio Code\n\n简称 vscode，是微软开发的开源的代码编辑器，支持多种语言，有大量插件可以安装，功能全面，是前端开发必备的工具。\n\n（和 vs2010、vs2019 等不是一个东西）\n\n#### 安装\n\n[Visual Studio Code 官网](https://code.visualstudio.com/)\n\n### Typora\n\nTypora 是一款优秀的 Markdown 编辑器\n\n[Typora 官网](https://typora.io/)\n\n## Hexo 的使用\n\n_安装和使用过程建议以官方文档为准，本文仅作辅助_\n\n[Hexo 官方中文文档](https://hexo.io/zh-cn/)\n\n> 查阅并通过文档获取知识和技术是一个有灵魂的程序员基本技能，这项技能是通过学习过程中不断积累出来的。\n>\n> 很多程序员只会写代码，没有灵魂，是因为他们只会老师教的，不会自己获取知识，编程技术更新迭代很快，如果没有自己阅读文档获取知识的能力，这样的程序员很快就会被时间淘汰掉。这也是编程补课班批量生产出来的程序员和其他程序员的本质区别。\n\n### 安装 Hexo\n\n在 CMD 中运行以下命令\n\n```bash\nnpm install -g  hexo-cli\n```\n\n`-g`是全局安装的意思\n\n之后就会出现进度条和一些文字，等待其完成安装。\n\n![image-20211001093714184](image-20211001093714184-1633066914649.png)\n\n安装完成后，我们可以通过下面命令查看安装是否成功\n\n```bash\nhexo -v  # 查看Hexo版本\n```\n\n正确输出结果如下\n\n![image-20211001093851226](image-20211001093851226-1633066914650.png)\n\n这样，Hexo 博客框架就安装好了\n\n### 博客初始化\n\n先将 CMD 的位置定位到你想要初始化博客的目录\n\n比如，你想在 D 盘的 myblog 目录里面建立博客\n\n首先新建文件夹\n\n然后打开 CMD 命令窗口\n\n输入命令切换操作目录\n\n```bash\ncd /d D:\\myblog\n```\n\n接着使用下面命令开始初始化博客文件夹\n\n```bash\nhexo init\n```\n\n接着 hexo 开始构建内容\n\n![image-20211001094951691](image-20211001094951691-1633066914650.png)\n\n网络良好的情况下很快就可以完成初始化\n\n安装完成后，文件夹变成如下结构\n\n```\n.\n├── _config.landscape.yml\n├── _config.yml\t\t\t\t\t// 整个博客的配置\n├── package.json\t\t\t\t// 项目所需模块项目的配置信息\n├── node_modules\t\t\t\t// 包含node依赖包的文件夹\n│   ├── ... \t\t\t\t\t// 若干node依赖包\n├── scaffolds\t\t\t\t\t// 命令生成文章的模板文件夹\n│   ├── draft.md\n│   ├── page.md\n│   └── post.md\n├── source\t\t\t\t\t\t// 用于存放创作的文章\n│   └── _posts\n│       └── hello-world.md\n├── themes\t\t\t\t\t\t// 存放主题的文件夹\n└── public\t\t\t\t\t\t// 存放hexo框架生成的静态文件\n    └──  ...\n```\n\n这个时候，Hexo 就为我们生成了一个博客，通过下面操作可以预览\n\n```bash\nhexo s\n```\n\n如果出现以下提示\n\n![image-20211001100914140](image-20211001100914140-1633066914650.png)\n\n点击允许访问即可。\n\n可以看到命令行里出现这个\n\n![image-20211001101010104](image-20211001101010104-1633066914650.png)\n\n这时候我们使用浏览器访问 [http://localhost:4000](http://localhost:4000)即可看到博客样例\n\n![image-20211001101252815](image-20211001101252815-1633066914651.png)\n\n当然这并不是我们想要的样子，就像我们买到一台新手机一样，我们需要对 Hexo 进行配置\n\n### 配置博客\n\n博客目录下的`_config.yml`是整个博客的配置文件。\n\n右键选择 vscode 打开便可以编辑配置文件\n\n**_<u>请不要使用 Windows 记事本编辑此文件！！！！！</u>_**\n\n![image-20211001101722815](image-20211001101722815-1633066914650.png)\n\n![image-20211001101746970](image-20211001101746970-1633066914650.png)\n\n下面开始配置 hexo，这里只讲述初次使用者必需的部分，更多进阶操作请访问[hexo 官方网站](https://hexo.io/)。\n\n#### # Site：\n\n| 属性名称      | 描述             | 常用属性值                                                                                                        |\n| :------------ | :--------------- | :---------------------------------------------------------------------------------------------------------------- |\n| `title`       | 博客/网站的标题  | 你自己的 Blog 标题                                                                                                |\n| `subtitle`    | 博客/网站副标题  | -                                                                                                                 |\n| `description` | 网站、博客的描述 | -                                                                                                                 |\n| `keywords`    | 关键字           | 网站的关键词，使用半角逗号分隔开多个关键词，关键词对 SEO 的优化有一定的作用                                       |\n| `author`      | 作者             |                                                                                                                   |\n| `language`    | 语言             | 默认 en；建议改成`zh-CN`（中文）                                                                                  |\n| `timezone`    | 网站时区         | Hexo 默认使用您电脑的时区。也可换成`America/New_York`, `UTC` 。一般的，对于中国大陆地区可以使用 `Asia/Shanghai`。 |\n\n> 其中，`title`：网站的名字，会写在`hexo generator`命令生成后的 public 文件夹下的 index.html 文件的 title 标签里\n>\n> `description`主要用于 SEO(即：搜索引擎优化)，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。`author`参数用于主题显示文章的作者。\n\n#### # URL：\n\n| 属性名称                     | 描述                                                                                    | 常用属性值                  |\n| ---------------------------- | --------------------------------------------------------------------------------------- | --------------------------- |\n| `url`                        | 网址                                                                                    | -                           |\n| `root`                       | 网站根目录                                                                              | -                           |\n| `permalink`                  | 文章的 [永久链接](https://hexo.io/zh-cn/docs/permalinks.html) 格式                      | `:year/:month/:day/:title/` |\n| `permalink_defaults`         | 永久链接中各部分的默认值                                                                |                             |\n| `pretty_urls`                | 改写 [`permalink`](https://hexo.io/zh-cn/docs/variables) 的值来美化 URL                 |                             |\n| `pretty_urls.trailing_index` | 是否在永久链接中保留尾部的 `index.html`，设置为 `false` 时去除                          | `true`                      |\n| `pretty_urls.trailing_html`  | 是否在永久链接中保留尾部的 `.html`, 设置为 `false` 时去除 (_对尾部的 `index.html`无效_) | `true`                      |\n\n> 网站存放在子目录\n>\n> 如果您的网站存放在子目录中，例如 `http://yoursite.com/blog`，则请将您的 `url` 设为 `http://yoursite.com/blog` 并把 `root` 设为 `/blog/`。\n\n例如：\n\n```yaml\n# 比如，一个页面的永久链接是 http://example.com/foo/bar/index.html\npretty_urls:\n  trailing_index: false\n# 此时页面的永久链接会变为 http://example.com/foo/bar/\n```\n\n> 可以注意到，`permalink`是文章的永久链接格式，可以在 permalink 这里配置，如默认中的配置，在 hello world 文章中就会是这样的 url：`http://localhost:4000/2020/09/26/hello-world/`\n>\n> 同时，在使用 hexo g 生成的 public 文件夹里面，文件夹的层级也会按这个配置:\n\n[![image-20201003230255713](20201124214020-1633066914650.png)]\n\n#### # Directory：\n\n| 属性名称       | 描述                                                                                        | 常用属性值       |\n| -------------- | ------------------------------------------------------------------------------------------- | ---------------- |\n| `source_dir`   | 资源文件夹，存放 hexo 文章的文件夹，我们写的 md 文件都放在这个配置对应的文件夹下。          | `source`         |\n| `public_dir`   | 公共文件夹，这个文件夹用于存放`hexo g`生成的站点文件。                                      | `public`         |\n| `tag_dir`      | 标签文件夹，按标签存放文章的目录，在给文章添加`tags`标签后会有                              | `tags`           |\n| `archive_dir`  | 归档文件夹                                                                                  | `archives`       |\n| `category_dir` | 分类文件夹，按分类存放文章的目录，在给文章添加`category`标签后会有                          | `categories`     |\n| `code_dir`     | Include code 文件夹                                                                         | `downloads/code` |\n| `i18n_dir`     | 国际化（i18n）文件夹                                                                        | `:lang`          |\n| `skip_render`  | 跳过指定文件的渲染，您可使用 [glob 表达式](https://github.com/isaacs/node-glob)来匹配路径。 |                  |\n\n> **提示:**\n>\n> 如果您刚刚开始接触 Hexo，通常没有必要修改这一部分的值。\n> 没到自己制作 theme 的水平别修改！\n\n#### # Writing：\n\n| 属性名称                | 描述                                                                                                         | 常用属性值 |\n| :---------------------- | :----------------------------------------------------------------------------------------------------------- | :--------- |\n| `new_post_name`         | 新文章的文件名称                                                                                             | :title.md  |\n| `default_layout`        | 预设布局                                                                                                     | post       |\n| `auto_spacing`          | 在中文和英文之间加入空格                                                                                     | false      |\n| `titlecase`             | 把标题转换为 title case                                                                                      | false      |\n| `external_link`         | 在新标签中打开链接                                                                                           | true       |\n| `external_link.enable`  | 在新标签中打开链接                                                                                           | `true`     |\n| `external_link.field`   | 对整个网站（`site`）生效或仅对文章（`post`）生效                                                             | `site`     |\n| `external_link.exclude` | 需要排除的域名。主域名和子域名如 `www` 需分别配置                                                            | `[]`       |\n| `filename_case`         | 把文件名称转换为 (1) 小写或 (2) 大写                                                                         | 0          |\n| `render_drafts`         | 显示草稿                                                                                                     | false      |\n| `post_asset_folder`     | 启动 [Asset 文件夹](https://hexo.io/zh-cn/docs/asset-folders)                                                | false      |\n| `relative_link`         | 把链接改为与根目录的相对位址                                                                                 | false      |\n| `future`                | 显示未来的文章                                                                                               | true       |\n| `highlight`             | 代码块的设置, see [Highlight.js](https://hexo.io/docs/syntax-highlight#Highlight-js) section for usage guide |            |\n| `prismjs`               | 代码块的设置, see [PrismJS](https://hexo.io/docs/syntax-highlight#PrismJS) section for usage guide           |            |\n\n> 相对地址\n>\n> 默认情况下，Hexo 生成的超链接都是绝对地址。例如，如果您的网站域名为 `example.com`,您有一篇文章名为 `hello`，那么绝对链接可能像这样：`http://example.com/hello.html`，它是**绝对**于域名的。相对链接像这样：`/hello.html`，也就是说，无论用什么域名访问该站点，都没有关系，这在进行反向代理时可能用到。通常情况下，建议使用绝对地址。\n\n> **new_post_name**：新文章的默认名称，我们是使用 hexo new 来构造文章的，生成的文章名就是通过这里配置的，默认为: `title.md`，[也就是标题.md](http://xn--ujqu05ajxh7zbf63i.md/)\n\n> **default_layout**：预设布局，`hexo new`可以创建三种文件，post/帖子，draft/草稿，page/页面，这里设置默认值在使用`hexo new`就可以直接创建对应默认类型的文章，设置了 post 就等同于说在命令行执行`hexo new <name>`和执行`hexo new post <name>`是一样的，也可以设置为 draft 和 page\n\n> **post_asset_folder**：是否启动资源文件夹，对于我们的网站，如果我们的文章里面有图片，我们可以在 source 文件夹下建立一个统一的 images 文件夹来存放图片，但是如果有的文章有很多的资源文件如图片，我们可以通过设置该配置为 true，这样在 source 文件夹下创建文件的同时也会创建一个同名文件夹来存放相应的资源，比如我设置为 true，然后执行 hexo new newPost\n\n> **highlight**：代码块的设置\n>\n> - `enable`：开启代码高亮，默认为 true\n> - `auto_detect`：如果未指定语言，就自动检测，默认为 false\n> - `line_number`：显示代码的行数，默认为 true\n> - `tab_replace`：用 n 个空格来代表 tab 键，如果值为空，则不会代替 tab 键\n> - `wrap`：是否将代码放在 table 标签里，默认为 true\n> - `hljs`：是否对 CSS 类使用 hljs-\\*前缀，默认为 false\n\n#### # Home page setting：\n\n```yaml\n#  Home page setting\nindex_generator:\n  path: ''\n  per_page: 10\n  order_by: -date\n```\n\n**index_generator**：主页相关的设置\n\n> `path`：主页对应的路径，默认为’’，即域名根目录就是主页的路径\n>\n> ```yaml\n> per_page`：每页显示的帖子数，默认为10\n> ```\n>\n> `order_by`：帖子的排序，默认为-date，即按日期倒序排\n\n#### # Category & Tag\n\n```yaml\n# Category & Tag\ndefault_category: uncategorized # 默认分类\ncategory_map: # 分类别名\ntag_map: # 标签别名\n```\n\n是否在页面开头插入 meta 标签，默认为 true\n\n#### # Metadata elements\n\n```yaml\n# Metadata elements\n## https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta\nmeta_generator: true\n```\n\n#### # Date / Time format\n\n```yaml\n# Date / Time format\n## Hexo uses Moment.js to parse and display date\n## You can customize the date format as defined in\n## http://momentjs.com/docs/#/displaying/format/\ndate_format: YYYY-MM-DD\ntime_format: HH:mm:ss\n## updated_option supports 'mtime', 'date', 'empty'\nupdated_option: 'mtime'\n```\n\n> **date_format**：日期格式，默认为 YYYY-MM-DD，即年月日\n> **time_format**：时间格式，默认为 HH:mm:ss，即时分秒\n> **use_date_for_updated**：启用以后，如果 Front Matter 中没有指定 updated（文件更新日期），post.updated 将会使用 date 的值而不是文件的创建时间，默认值为 true\n\n#### # Pagination\n\n```yaml\nper_page: 10\npagination_dir: page\n```\n\n> **per_page**：分页时每页的文章数，如果为 0 则不分页，默认为 10\n> **pagination_dir**: 分页的目录，默认为 page，对应于 public 文件夹下的 archives 文件夹下的 page 文件夹，如果只有一页是不会生成这个文件夹的\n\n#### # Include / Exclude file(s)\n\n```yaml\n# include:/exclude: options only apply to the 'source/' folder\ninclude:\nexclude:\nignore:\n```\n\n> **include**：Hexo 默认会忽略隐藏文件和文件夹（包括名称以下划线和 . 开头的文件和文件夹，Hexo 的 \\_posts 和 \\_data 等目录除外）。通过设置此字段将使 Hexo 处理他们并将它们复制到 source 目录下。\n> **exclude**：Hexo 会忽略这些文件和目录\n> **ignore**：忽略的文件\n> 要注意的是，这里要写入的是数组，而 yaml 的数组要用-值表示数组中一个元素或者直接采用 js 中数组的写法[]\n\n#### # Extensions\n\n```yaml\ntheme: landscape\n```\n\n> **theme**当前主题名称。值为`false`时禁用主题。\n\n```yaml\ndeploy:\n  type: ''\n```\n\n> **deploy**部署部分的设置\n\n这里给出一个最后远端部署 github 的配置例子：\n\n```yaml\ndeploy:\n  type: git\n  repo: <repository url> # 库地址\n  branch: [branch] # 分支名称\n  message: [message] # 自定义提交信息\n```\n\n### 开始创作\n\n使用下面命令新建文章\n\n```bash\nhexo new <title>\n```\n\n例如\n\n```bash\nhexo new \"你的第一个个人网站\"\n```\n\n注意使用英文引号\n\n![image-20211001105153297](image-20211001105153297-1633066914650.png)\n\n> 注意：新建一篇文章。完整的命令其实是：`$ hexo new [layout] <title>`，其中`layout`可以忽略不写。\n>\n> 如果没有设置 `layout` 的话，默认使用 `_config.yml` 中的 `default_layout` 参数代替（默认是 post）。\n>\n> 如果标题包含空格的话，请使用引号括起来。\n>\n> **关于文章模板**\n>\n> 在新建文章中使用的`post`参数，就是模板的名称，在使用`hexo new post <title>`命令进行新建文章时，系统会自动在`scaffolds`文件夹中搜寻名为`post`的文件，根据其中的内容生成新的`.md`文章文件。后续随着配置项的增多，可以自行设置不同类型的模板。\n\n之后你就可以在`/source/_posts`文件夹中看到你新建的博客 Markdown 文件，比如 `你的第一个个人网站.md`\n\n使用 Typora 软件打开你新建的博客。\n\n可以看到如下内容\n\n![image-20211001105549529](image-20211001105549529-1633066914651.png)\n\n如图所示框内内容为文章配置信息\n\n![image-20211001110032358](image-20211001110032358-1633066914651.png)\n\n其中`title`是标题，`date`是时间，`tags`是标签\n\n其中 tags 可以设置多个\n\n```yaml\ntags:\n - Hexo\n - Markdown\n```\n\n上面是一些基本配置，根据你的博客主题不同，博客主题可能会需要更多其他配置参数，来丰富其功能\n\n之后你便可以创作啦\n\n创作之后可以通过后续讲解的操作来预览和发布\n\n### 预览和发布\n\n#### 本地预览\n\n使用下面的命令可以本地预览博客\n\n```bash\nhexo s\n```\n\n如果出现以下提示\n\n![image-20211001100914140](image-20211001100914140-1633066914650.png)\n\n点击允许访问即可。\n\n可以看到命令行里出现这个\n\n![image-20211001101010104](image-20211001101010104-1633066914650.png)\n\n这时候我们使用浏览器访问 [http://localhost:4000](http://localhost:4000)即可看到博客样例\n\n![image-20211001101252815](image-20211001101252815-1633066914651.png)\n\n#### 生成静态文件\n\n使用命令\n\n```bash\nhexo g\n```\n\n可以在`/public`文件夹生成静态文件，我们可以将这个静态文件放到我们的 web 服务器或 pages 中，就可以远程访问了。\n\n![image-20211001113722685](image-20211001113722685-1633066914651.png)\n\n#### 发布\n\n生成静态文件后，我们选择 GitHub Pages 展示博客，[后面内容将会介绍](#Github-Pages)\n\n### 主题和个性化\n\nhexo 初始化后默认的主题样式可以在`_config.yml`中的 theme 中看到，是`landscape`。\n\n![image-20211001114234481](image-20211001114234481-1633066914651.png)\n\n你可以在 github 上搜索其他的主题，克隆下来，并进行配置。\n\n关于主题我们可以在 hexo 官网上搜索，但更建议直接在 github 上搜索 hexo-theme，选择 most-stars 筛选出最受欢迎的，在一次浏览各个 Demp 去找到你最喜欢的一个主题样式。\n\n![image-20211001132458269](image-20211001132458269-1633066914651.png)\n\n这里选择一个我比较喜欢的样式作为例子。\n\ngithub 搜索**[ hexo-theme-butterfly](https://github.com/jerryc127/hexo-theme-butterfly)**\n\n![image-20211001132555237](image-20211001132555237-1633066914651.png)\n\n> 新手其实推荐使用 Next 主题，因为这是最受欢迎的，所以他的参考资料最多。\n>\n> 我选择 Butterfly，首先这是一款由中国人开发的主题，对于中文的兼容性比较好。其次他的样式我比较喜欢。另外他的更新频率很高。\n\n**更换主题的命令如下：**\n\n在博客的根目录下，\n\n```bash\ngit clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly\n```\n\n> 其他的主题克隆命令类同，可以自行阅读文档。\n\n**应用主题：**\n\n修改站点配置文件`_config.yml`，把主题改为`butterfly`\n\n```bash\ntheme: butterfly\n```\n\n**安装插件：**\n如果你没有 pug 以及 stylus 的渲染器，请下载安装：\n\n```bash\nnpm install hexo-renderer-pug hexo-renderer-stylus --save\n```\n\n**升级建议：**\n因为主题经常会更新，为了防止每次更新替换掉原来配置好的`_config.yml`,可以通过以下方式避免被替换掉。\n\n> 如果已经在 `source/_data/` 创建了 `butterfly.yml`，请记得删除掉。\n\n首先， 把主题文件夹中的 `_config.yml` 复制到 **Hexo** 根目录里，同时重新命名为 `_config.butterfly.yml`。\n\n以后只需要在 `_config.butterfly.yml`进行配置就行。\n\n因为 Hexo 会自动合并主题中的`_config.yml`和 `_config.butterfly.yml`里的配置，如果存在同名配置，会使用`_config.butterfly.yml`的配置，其优先度较高，这样就能防止更新主题的时候，主题目录下的配置被更新，丢失之前的配置。\n\n## Github Pages\n\n首先在 blog 目录下使用终端安装一个插件：\n\n```bash\nnpm install  --save hexo-deployer-git\n```\n\n![image-20211001132120524](image-20211001132120524-1633066914652.png)\n\n然后配置根目录下的`_config.yml`：\n\n```yaml\ndeploy:\n  type: git\n  repo: ....      # 你的repository地址（建议ssh）\n  branch: master  # 你的项目branch，默认是master\n  message: blog\n```\n\n接着，在终端输入：\n\n```bash\nhexo d\n```\n\n根据提示输入你的 github 账号密码或者 ssh 私钥对应的密码，即可上传到云端。\n\n> 注意：在要求输入密码时，你输入之后密码是不显示的，这是为了安全，并非是你没输上。\n\n最后，刷新你的仓库，可以看到你博客的 public\\文件夹下内容已经上传成功，进入 settings 查看 github pages，可以看到已经绑定好了外域名，点开该域名即可访问。\n\n## FAQ\n\n### 如何在博客中插入图片\n\n#### 使用 hexo 资源文件夹\n\n- 第一步：安装插件，在 hexo 根目录打开终端,执行\n\n  ```bash\n  npm install hexo-asset-image --save\n  ```\n\n- 第二步：打开 hexo 的配置文件`_config.yml`\n\n找到 `post_asset_folder`，把这个选项从`false`改成`true`\n\n- ![image-20201005000457975](20201124214023-1633066914652.png)XXXX.md`博文时就会在`/source/\\_posts`目录下生成`XXXXXX`的文件夹，将你想在`XXXXX`博文中插入的图片放置到这个同名文件夹中即可，图片的命名随意。\n\n- 第四步：**添加图片**：在想添加的位置写入`![](图片名字.图片格式)`,例如`![](1.png)`。\n\n  ![image-20201005002150822](20201124214024-1633066914652.png)\n\n#### 使用图床\n\n不做详细介绍\n\n### 更多？\n\n欢迎补充\n\n## 内容参考\n\n部分内容来自\n\n- [https://zlhad.top/2020/10/05/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/](https://zlhad.top/2020/10/05/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/)\n- [https://lakphy.me/blog/2019/06/09/Hexo%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/](https://lakphy.me/blog/2019/06/09/Hexo%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/)\n","tags":["踩坑记录","hexo"]},{"title":"TensorFlow简单入门","url":"/blog/2021/01/25/TensorFlow简单入门/","content":"\n近期恰逢Google组织第三季TensorFlow Study Jam活动，再加上一直想学TensorFlow，就这么入坑了\n\n此处仅作学习笔记使用，仅作参考，初学还是建议跟一遍TensorFlow的官方MOOC教程。\n\n## 前提准备\n\n### 个人技能\n\n1. 有Python基础\n\n2. 了解机器学习相关知识\n\n   \n\n### 软件\n\n这里为了方便，使用 Python3 和 JupyterNotebook。\n\nPython3自然是为了运行代码\n\nJupyter Notebook是用来看教程的，Internet上很多教程都是写在Jupyter Notebook上面的，而且Jupyter Notebook的Python运行机制很方便使用（虽然运行速度是慢了些）\n\n### 实训平台\n\n这里可以有很多选择，这里推荐两个\n\n1. 中国大学MOOC上网易与TensorFlow联合打造的在线实训平台，每天有两小时使用时间（免费）https://ot.icourse163.org/#/course\n\n2. 阿里天池实训平台https://tianchi.aliyun.com/education\n\n   \n\n## 软件安装\n\n### Python\n\nWindows用户：自行下载Python.exe\n\nUbuntu用户：\n\n```sh\napt install python3\n```\n\n### 安装TensorFlow\n\n```shell\npip install tensorflow\n```\n\n### JupyterNotebook\n\n这里仅提供Ubuntu方案,Windwos用户请自行摸索\n\n```shell\npip install jupyter\njupyter notebook\n```\n\n## 从简单例子开始\n\n先看一个代码\n\n```python\nimport tensorflow as tf\nimport numpy as np\nfrom tensorflow import keras\n\nmodel = tf.keras.Sequential([keras.layers.Dense(units=1, input_shape=[1])])\nmodel.compile(optimizer='sgd', loss='mean_squared_error')\n\nxs = np.array([1.0, 2.0, 3.0, 4.0, 5.0, 6.0], dtype=float)\nys = np.array([1.0, 1.5, 2.0, 2.5, 3.0, 3.5], dtype=float)\n\nmodel.fit(xs, ys, epochs=1000)\n\nprint(model.predict([7.0]))\n```\n\n先观察这个代码，不需要理解，之后我会逐行讲解\n\n这些代码的用途是训练一个可以计算一次函数的机器学习\n\n下面我们开始逐句讲解\n\n```python\nimport tensorflow as tf\nimport numpy as np\nfrom tensorflow import keras\n```\n\n这句的意思是引入tensorflow和numpy的包\n\n```python\nmodel = tf.keras.Sequential([keras.layers.Dense(units=1, input_shape=[1])])\n```\n\n# 锅没写完，未完待续。。。。。","tags":["TensorFlow"]},{"title":"利用iPhone线性震动马达制作骨传导耳机","url":"/blog/2020/12/23/利用iPhone线性震动马达制作骨传导耳机/","content":"\n北京时间2015年9月10日凌晨1点，苹果公司在旧金山的比尔·格雷厄姆市政礼堂举行2015苹果秋季新品发布会。本次发布会中，发布了新品iPhone 6s、iPhone 6s Plus，Apple Watch更多的表带和机身款式、12.9英寸的iPad Pro、全新可以打游戏的Apple TV。其中，iPhone 6s与iPhone 6s Plus为广大果粉带来了诸多“黑科技”：3D touch、1200万像素后置摄像头、livephoto与4K摄录、强劲的A9处理器……这让去年因iPhone 6和5s相比提高不大而郁闷了一年的果粉们过足了瘾。然而，有一项真正名副其实的“黑科技”却被大众忽略了，甚至在发布会上也只是被一笔带过，那就是——**Taptic Engine**。\n\n![img](v2-c2a62b1ba82fbf82893798957c251c31_r.jpg)\n\n这个Taptic Engine就是我们这篇文章的主角，就是线性震动马达。在苹果之后发布的产品中都会看到它，可以说，它是苹果之后发布的产品的灵魂，大幅提升了苹果产品的体验。\n\n以致于苹果公司不惜浪费大量空间，在[Apple Watch](https://www.apple.com.cn/watch/)中也加入了Taptic Engine。\n\n![img](v2-7fa87540e4a6d81ecc67bfdf907c29c9_r.jpg)\n\n甚至在iPhone7之后，苹果使用来模拟实体按键按下的感觉。可见Taptic Engine的动力强劲。\n\n这篇我们来利用Taptic Engine来制作骨传导耳机。\n\n# 目标成品\n\n目标为制作一个利用Taptic Engine震动发声的骨传导耳机。\n\n成品如图\n\n![1608721324144](1608721324144.jpg)\n\n# 材料准备\n\n建议材料一览：\n\n1. iPhone 的 Taptic Engine 线性震动马达 *4\n2. **能用就行**的3.5mm耳机线 *1\n3. 功放板 *1\n4. USB供电线 *1\n\n![1608721324085](1608721324085.jpg)\n\n## Taptic Engine\n\n这里建议选择选择iPhone7Plus的Taptic Engine，主要原因是在iPhone7系列上苹果首次取消home键，并用Taptic Engine模拟home键按下的震动效果，再加上plus版本身就要大一些，选择iPhone7Plus的Taptic Engine是性价比较高的选择。我图中列出的Taptic Engine售价`4`RMB/个，据说是买贵了，读者可以自行上某宝寻找便宜的可靠的商家。\n\n关于Taptic Engine的购买数量，按照需求，应该是只要两块就够了，但由于Taptic Engine的触点不好焊接，虽然焊接这个事情是右手就行，但手有时候也会丢，建议买4个备用，两个焊接两个备用。我个人是买了4个，焊废了1个。\n\n![1608721324262](1608721324262.jpg)\n\n\n\n## 3.5mm耳机线\n\n这个要求不高，能响就行，另外建议不要买带线控的耳机，不方便改造。\n\n\n\n## 功放板\n\n前面放的那个板子是一个比较廉价的解决方案\n\n![1608721324223](/1608721324223.jpg)\n\n另外可以使用下面这个板子，贵两块，多一个电位器，可以调节音量。\n\n![1608721324134](/1608721324134.jpg)\n\n\n\n## USB供电线\n\n这个啊，也是能用就行，要求只是有一个USB头就行了，方便用充电宝供电，可以像我一样选择USB转DC的供电线，之后再把DC头剪掉就行了。\n\n\n\n# 开始焊接\n\n## 焊接马达触点\n\n马达有两种焊接方式，任选一种焊接方式即可\n\n### 1、马达侧部\n\n![image-20201223193447349](/image-20201223193447349.png)\n\n马达侧部\n\n![image-20201223193108786](/image-20201223193108786.png)\n\n这里可以发现侧部有6个触点，我们使用左右两个触点，不分正负极\n\n将耳机线的分支部分剪下，剖开首尾两部，会发现里面有两根线，在线头和触点上点一些焊锡，然后焊接在左右两触点上即可\n\n![1608721324173](/1608721324173-1610286359255.jpg)![1608721324232](/1608721324232.jpg)\n\n### 2、马达排线上\n\n![image-20210110214759250](/image-20210110214759250.png)\n\n如图，这里时马达的排线，我们用小刀等工具将其表面划开\n\n![image-20210110214926296](/image-20210110214926296.png)\n\n完事以后就是这个样子，这就是我们要的两个触点，不分正负极。\n\n将耳机线的分支部分剪下，剖开首尾两部，会发现里面有两根线，在线头和触点上点一些焊锡，然后焊接在左右两触点上即可![1608721324173](/1608721324173-1610286359255.jpg)\n\n### 提醒\n\n1. 此步焊接较为复杂，也容易损坏马达，建议多备几个马达（某同学已经挂了好几块了）\n2. 由于焊点较近，建议焊接完成后用万用表测试一下，以防短路/断路\n3. 建议焊完并测试无误后直接上胶枪粘死，以防线松\n\n## 焊接功放板\n\n# 施工ing.......未完待续","tags":["电子"]},{"title":"C语言常见文件处理","url":"/blog/2020/12/20/C语言常见文件处理/","content":"\n每个编程语言学到文件操作、字符串操作、网络连接什么什么的就开始有各种各样的库函数需要记忆，有的比较常用还比较好记，有的遇到了却没记住，那就只能请教Google了。但考试时候不能Google，本篇旨在总结C语言中常见的文件处理操作，便于查阅和记忆。\n\n- [FILE文件类型](#file文件类型)\n- [fopen() 打开文件](#fopen-打开文件)\n- [fclose() 关闭文件](#fclose-关闭文件)\n- [fputc() 将字符写入文件](#fputc-将字符写入文件)\n- [fputs() 将字符串写入文件](#fputs-将字符串写入文件)\n- [fprintf() 格式化写入](#fprintf-格式化写入)\n- [fgetc() 从文件中读取字符](#fgetc-从文件中读取字符)\n- [fgets() 从文件中读取字符串](#fgets-从文件中读取字符串)\n- [fscanf() 格式化读取](#fscanf-格式化读取)\n- [fwrite() 二进制写入](#fwrite-二进制写入)\n- [fread() 二进制读取](#fread-二进制读取)\n- [rewind() 位置指针指向文件头](#rewind-位置指针指向文件头)\n- [fseek() 改变文件位置指针](#fseek-改变文件位置指针)\n- [ftell() 获取文件位置指针相对于文件头的位置](#ftell-获取文件位置指针相对于文件头的位置)\n- [fflush() 刷新流 stream 的输出缓冲区](#fflush-刷新流-stream-的输出缓冲区)\n- [feof() 测试给定流 stream 的文件结束标识符](#feof-测试给定流-stream-的文件结束标识符)\n- [freopen()](#freopen)\n- [remove() 删除文件](#remove-删除文件)\n- [rename() 重命名/移动文件](#rename-重命名移动文件)\n\n\n\n## FILE文件类型\n\nFILE类型是一个用来表示文件的结构体\n\n其在TC2.0编译器中的原型如下：\n\n```C\ntypedef struct  {\n        short           level;          /* fill/empty level of buffer */\n        unsigned        flags;          /* File status flags    */\n        char            fd;             /* File descriptor      */\n        unsigned char   hold;           /* Ungetc char if no buffer */\n        short           bsize;          /* Buffer size          */\n        unsigned char   *buffer;        /* Data transfer buffer */\n        unsigned char   *curp;          /* Current active pointer */\n        unsigned        istemp;         /* Temporary file indicator */\n        short           token;          /* Used for validity checking */\n}       FILE;                           /* This is the FILE object */\n```\n\n其在VC6.0编译器中的原型如下：\n\n```C\nstruct _iobuf {\n　　　　char *_ptr; //文件输入的下一个位置\n　　　　int _cnt; //当前缓冲区的相对位置\n　　　　char *_base; //指基础位置(即是文件的起始位置)\n　　　　int _flag; //文件标志\n　　　　int _file; //文件的有效性验证\n　　　　int _charbuf; //检查缓冲区状况,如果无缓冲区则不读取\n　　　　int _bufsiz; //\n　　　　char *_tmpfname; //临时文件名\n        };\ntypedef struct _iobuf FILE;\n```\n\n在日常使用中，FILE类型常以指针形式使用。\n\n\n\n## fopen() 打开文件\n\n该函数用于打开一个文件，函数原型如下：\n\n```C\nFILE *fopen( const char * filename, const char * mode );\n```\n\n该函数接收两个字符串类型参数，函数将会打开一个文件，并将建立这个文件的FILE类型变量，并且返回一个指向该变量的FILE类型指针。\n\n其中，\n\n`filename`表示文件地址，数据类型为字符串，允许使用相对地址或绝对地址。例如在Windows系统下`\"D:\\\\data\\\\file.txt\"`可以用来表示地址，在Linux系统下`\"/mnt/test.txt\"`可以用来表示地址；\n\n`mode`表示访问模式，数据类型为字符串，它的值可以为下列几种：\n\n| 模式 | 描述                                                         |\n| :--- | :----------------------------------------------------------- |\n| r    | 打开一个已有的文本文件，允许读取文件。                       |\n| w    | 打开一个文本文件，允许写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会从文件的开头写入内容。如果文件存在，则该会被截断为零长度，重新写入。 |\n| a    | 打开一个文本文件，以追加模式写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会在已有的文件内容中追加内容。 |\n| r+   | 打开一个文本文件，允许读写文件。                             |\n| w+   | 打开一个文本文件，允许读写文件。如果文件已存在，则文件会被截断为零长度，如果文件不存在，则会创建一个新文件。 |\n| a+   | 打开一个文本文件，允许读写文件。如果文件不存在，则会创建一个新文件。读取会从文件的开头开始，写入则只能是追加模式。 |\n| rb   | 打开一个已有的二进制文件，允许读取文件。                     |\n| wb   | 打开一个二进制文件，允许写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会从文件的开头写入内容。如果文件存在，则该会被截断为零长度，重新写入。 |\n| ab   | 打开一个二进制文件，以追加模式写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会在已有的文件内容中追加内容。 |\n| rb+  | 打开一个二进制文件，允许读写文件。                           |\n| wb+  | 打开一个二进制文件，允许读写文件。如果文件已存在，则文件会被截断为零长度，如果文件不存在，则会创建一个新文件。 |\n| ab+  | 打开一个二进制文件，允许读写文件。如果文件不存在，则会创建一个新文件。读取会从文件的开头开始，写入则只能是追加模式。 |\n\nExample:\n\n```C\nFILE *fp = fopen(\"/tmp/test.txt\", \"w+\");\n```\n\n\n\n## fclose() 关闭文件\n\n该函数用于关闭一个文件，函数原型如下：\n\n```c\nint fclose( FILE *fp );\n```\n\n该函数接收一个FILE类型指针变量，将会关闭这个FILE类型指针变量指向的文件，并且返回一个int类型的值。\n\n其中\n\n`fp`为一个指向所要关闭文件的FILE类型指针；\n\n如果成功关闭文件，`fclose( )` 函数返回零，如果关闭文件时发生错误，函数返回 `EOF`。这个函数实际上，会清空缓冲区中的数据，关闭文件，并释放用于该文件的所有内存。`EOF` 是一个定义在头文件 `stdio.h` 中的常量。\n\nExample:\n\n```C\nfclose(fp);\n```\n\n\n\n## fputc() 将字符写入文件\n\n该函数用于将字符输出/写入到文件中，其原型如下：\n\n```c\nint fputc( int c, FILE *fp );\n```\n\n该函数接收一个int类型参数`c`和一个FILE类型指针`fp`，会将ASCII码为`c`的单个字符写入到`fp`指针所指向的文件中。如果写入成功，位置指针会自动后移一个字节的位置，并且返回`c`作为函数的返回值。如果写入失败，则返回`EOF`。\n\n其中，\n\n`c`为要写入字符的ASCII码；\n\n`fp`为指向要写入文件的FILE类型指针。\n\nExample:\n\n```c\nfputc(48,fp);\n```\n\n\n\n## fputs() 将字符串写入文件\n\n该函数用于将字符串输出/写入到文件中，其原型如下：\n\n```c\nint fputs( const char *s, FILE *fp );\n```\n\n该函数接收一个char类型指针变量`s`和一个FILE类型指针变量fp，可以将指针s指向的字符串写入到fp所指向的文件中，如果写入成功，位置指针自动后移相应字节数，并且返回一个非负整数；否则，返回`EOF`。\n\n**注意：**指针s指向的字符串需以`\\0`结束，但写入字符串时不会写入`\\0`。\n\n其中，\n\n`s`为char类型指针变量，指向要写入的字符串的首地址；\n\n`fp`为FILE类型指针变量，指向要写入的文件。\n\nExample：\n\n```c\nfputs(\"hello\",fp);\n```\n\n\n\n## fprintf() 格式化写入\n\n该函数用于格式化写入文件，其原型如下：\n\n```c\nint fprintf(FILE *stream, const char *format, ...);\n```\n\n基本用法与`printf()`函数类似，接收若干个参数，第一个参数为文件指针，剩余参数与`printf()`函数类似，如果写入成功，则返回写入的字符总数，否则返回一个负数。\n\n其中，\n\n`stream`为指向输出文件的FILE类型指针。当该参数为`stdout`时该函数功能与`printf()`函数相同。\n\n`format`是 C 字符串，包含了要被写入到流 stream 中的文本。它可以包含嵌入的 format 标签，format 标签可被随后的附加参数中指定的值替换，并按需求进行格式化。format 标签属性是 `%[flags][width][.precision][length]specifier`，具体讲解如下：\n\n| specifier（说明符） | 输出                                      |\n| :------------------ | :---------------------------------------- |\n| c                   | 字符                                      |\n| d 或 i              | 有符号十进制整数                          |\n| e                   | 使用 e 字符的科学科学记数法（尾数和指数） |\n| E                   | 使用 E 字符的科学科学记数法（尾数和指数） |\n| f                   | 十进制浮点数                              |\n| g                   | 自动选择 %e 或 %f 中合适的表示法          |\n| G                   | 自动选择 %E 或 %f 中合适的表示法          |\n| o                   | 有符号八进制                              |\n| s                   | 字符的字符串                              |\n| u                   | 无符号十进制整数                          |\n| x                   | 无符号十六进制整数                        |\n| X                   | 无符号十六进制整数（大写字母）            |\n| p                   | 指针地址                                  |\n| n                   | 无输出                                    |\n| %                   | 字符                                      |\n\n| flags（标识） | 描述                                                         |\n| :------------ | :----------------------------------------------------------- |\n| -             | 在给定的字段宽度内左对齐，默认是右对齐（参见 width 子说明符）。 |\n| +             | 强制在结果之前显示加号或减号（+ 或 -），即正数前面会显示 + 号。默认情况下，只有负数前面会显示一个 - 号。 |\n| (space)       | 如果没有写入任何符号，则在该值前面插入一个空格。             |\n| #             | 与 o、x 或 X 说明符一起使用时，非零值前面会分别显示 0、0x 或 0X。 与 e、E 和 f 一起使用时，会强制输出包含一个小数点，即使后边没有数字时也会显示小数点。默认情况下，如果后边没有数字时候，不会显示显示小数点。 与 g 或 G 一起使用时，结果与使用 e 或 E 时相同，但是尾部的零不会被移除。 |\n| 0             | 在指定填充 padding 的数字左边放置零（0），而不是空格（参见 width 子说明符）。 |\n\n| width（宽度） | 描述                                                         |\n| :------------ | :----------------------------------------------------------- |\n| (number)      | 要输出的字符的最小数目。如果输出的值短于该数，结果会用空格填充。如果输出的值长于该数，结果不会被截断。 |\n| *             | 宽度在 format 字符串中未指定，但是会作为附加整数值参数放置于要被格式化的参数之前。 |\n\n| .precision（精度） | 描述                                                         |\n| :----------------- | :----------------------------------------------------------- |\n| .number            | 对于整数说明符（d、i、o、u、x、X）：precision 指定了要写入的数字的最小位数。如果写入的值短于该数，结果会用前导零来填充。如果写入的值长于该数，结果不会被截断。精度为 0 意味着不写入任何字符。 对于 e、E 和 f 说明符：要在小数点后输出的小数位数。 对于 g 和 G 说明符：要输出的最大有效位数。 对于 s: 要输出的最大字符数。默认情况下，所有字符都会被输出，直到遇到末尾的空字符。 对于 c 类型：没有任何影响。 当未指定任何精度时，默认为 1。如果指定时不带有一个显式值，则假定为 0。 |\n| .*                 | 精度在 format 字符串中未指定，但是会作为附加整数值参数放置于要被格式化的参数之前。 |\n\n| length（长度） | 描述                                                         |\n| :------------- | :----------------------------------------------------------- |\n| h              | 参数被解释为短整型或无符号短整型（仅适用于整数说明符：i、d、o、u、x 和 X）。 |\n| l              | 参数被解释为长整型或无符号长整型，适用于整数说明符（i、d、o、u、x 和 X）及说明符 c（表示一个宽字符）和 s（表示宽字符字符串）。 |\n| L              | 参数被解释为长双精度型（仅适用于浮点数说明符：e、E、f、g 和 G）。 |\n\n\n\n## fgetc() 从文件中读取字符\n\n该函数用于从文件中读取一个字符，其原型如下：\n\n```c\nint fgetc( FILE * fp );\n```\n\n该函数接收一个指向所要读取的文件的FILE类型指针，函数从`fp`所指向的输入文件中读取一个字符。如果读取成功，返回值是所读取的字符的ASCII码值，并且位置指针向后移动一个字节；如果发生错误则返回 EOF。\n\nExample：\n\n```c\nchar ch=fgetc(fp);\n```\n\n\n\n## fgets() 从文件中读取字符串\n\n该函数用于从文件中读取一个字符串，其原型如下：\n\n```c\nchar *fgets( char *buf, int n, FILE *fp );\n```\n\n该函数接收一个char类型指针`buf`，一个int类型变量`n`，一个FILE类型指针`fp`。\n\n函数从`fp`所指向的文件中读取 n - 1 个字符。它会把读取的字符串复制到`buf`所指向的字符串，并在最后追加一个`NULL`字符来终止字符串。如果这个函数在读取最后一个字符之前就遇到一个换行符 '\\n' 或文件的末尾 EOF，则只会返回读取到的字符，包括换行符。读取成功后位置指针自动向后移动 n - 1 个字节位置。\n\n函数返回值为char类型指针`buf`。\n\n其中，\n\n`buf`为cahr类型指针变量，指向将要储存字符串的首地址；\n\n`n`为int类型变量，表示要读取字符串长度(包括`\\0`)；\n\n`fp`为FILE类型指针变量，指向要读取的文件。\n\n\n\n## fscanf() 格式化读取\n\n该函数用于格式化读取文件，其原型如下：\n\n```c\nint fscanf(FILE *stream, const char *format, ...);\n```\n\n基本用法与`scanf()`函数类似，接收若干个参数，第一个参数为文件指针，剩余参数与`scacnf()`函数类似，如果读取成功，该函数返回成功匹配和赋值的个数。如果到达文件末尾或发生读错误，则返回 EOF。\n\n其中，\n\n`stream`为指向输出文件的FILE类型指针。当该参数为`stdin`时该函数功能与`printf()`函数相同。\n\n`format`是 C 字符串，包含了以下各项中的一个或多个：*空格字符、非空格字符* 和 *format 说明符*。\nformat 说明符形式为 `[=%[*][width][modifiers]type=]`，具体讲解如下：\n\n| 参数      | 描述                                                         |\n| :-------- | :----------------------------------------------------------- |\n| *         | 这是一个可选的星号，表示数据是从流 stream 中读取的，但是可以被忽视，即它不存储在对应的参数中。 |\n| width     | 这指定了在当前读取操作中读取的最大字符数。                   |\n| modifiers | 为对应的附加参数所指向的数据指定一个不同于整型（针对 d、i 和 n）、无符号整型（针对 o、u 和 x）或浮点型（针对 e、f 和 g）的大小： h ：短整型（针对 d、i 和 n），或无符号短整型（针对 o、u 和 x） l ：长整型（针对 d、i 和 n），或无符号长整型（针对 o、u 和 x），或双精度型（针对 e、f 和 g） L ：长双精度型（针对 e、f 和 g） |\n| type      | 一个字符，指定了要被读取的数据类型以及数据读取方式。具体参见下一个表格。 |\n\n| 类型说明符 | 合格的输入                                                   | 参数的类型     |\n| :--------- | :----------------------------------------------------------- | :------------- |\n| c          | 单个字符：读取下一个字符。如果指定了一个不为 1 的宽度 width，函数会读取 width 个字符，并通过参数传递，把它们存储在数组中连续位置。在末尾不会追加空字符。 | char *         |\n| d          | 十进制整数：数字前面的 + 或 - 号是可选的。                   | int *          |\n| e,E,f,g,G  | 浮点数：包含了一个小数点、一个可选的前置符号 + 或 -、一个可选的后置字符 e 或 E，以及一个十进制数字。两个有效的实例 -732.103 和 7.12e4 | float *        |\n| o          | 八进制整数。                                                 | int *          |\n| s          | 字符串。这将读取连续字符，直到遇到一个空格字符（空格字符可以是空白、换行和制表符）。 | char *         |\n| u          | 无符号的十进制整数。                                         | unsigned int * |\n| x,X        | 十六进制整数。                                               | int *          |\n\n\n\n## fwrite() 二进制写入\n\n该函数用于将指定位置开始的指定字节数的内容写入到文件中，函数原型如下：\n\n```c\nsize_t fwrite(const void *ptr, size_t size, size_t n, FILE *fp);\n```\n\n（size_t 是在 stdio.h 和 stdlib.h 头文件中使用 typedef 定义的数据类型，表示无符号整数，也即非负数，常用来表示数量。）\n\n该函数接受4个参数，用于从内存的`ptr`地址开始，将连续`n*size`个字节的内容原样复制到`fp`所指向的文件中。并返回实际写入的数据块个数。\n\n其中，\n\n`ptr`为无类型指针变量，表示要输出数据在内存中的首地址；\n\n`size`为一个数据块的字节数；\n\n`n`为数据块的个数；\n\n`fp`为FILE类型的指针，指向要写入的文件。\n\nExample:\n\n```c\n#include<stdio.h>\nint main (){\n   FILE *fp;\n   char str[] = \"Lakphy YES!\";\n   fp = fopen( \"file.txt\" , \"w\" );\n   fwrite(str, sizeof(str) , 1, fp );\n   fclose(fp);\n   return(0);\n}\n```\n\n\n\n## fread() 二进制读取\n\n该函数用于读取文件中从当前位置开始的指定字节数内容，然后直接存储到内存中指定起始地址的内存空间中。其函数原型如下：\n\n```c\nsize_t fread(void *ptr, size_t size, size_t n, FILE *fp)\n```\n\n该函数接受四个参数，从`fp`打开的文件的当前位置开始，连续读取`n*size`个字节的内容，存储到`ptr`为首地址的内存中，返回值为实际读取到内存中的数据块个数。\n\n其中，\n\n`ptr`为无类型指针，表示要输入数据在内存中的首地址；\n\n`size`表示一个数据块的字节数；\n\n`n`为数据块的个数；\n\n`fp`为FILE类型的指针，指向要读取的文件。\n\nExample：\n\n```c\n#include <stdio.h>\n#include <string.h>\n \nint main()\n{\n   FILE *fp;\n   char c[] = \"Lakphy YES!\";\n   char buffer[20];\n \n   /* 打开文件用于读写 */\n   fp = fopen(\"file.txt\", \"w+\");\n \n   /* 写入数据到文件 */\n   fwrite(c, strlen(c) + 1, 1, fp);\n \n   /* 查找文件的开头 */\n   fseek(fp, 0, SEEK_SET);\n \n   /* 读取并显示数据 */\n   fread(buffer, strlen(c)+1, 1, fp);\n   printf(\"%s\\n\", buffer);\n   fclose(fp);\n   \n   return(0);\n}\n```\n\n\n\n## rewind() 位置指针指向文件头\n\n该函数可以使位置指针指向文件头，函数原型如下：\n\n```c\nvoid rewind(FILE *fp);\n```\n\n使`fp`指针指向的文件的位置指针指向文件头，同时清除和文件流相关的错误和EOF标记，无返回值。\n\n\n\n## fseek() 改变文件位置指针\n\n该函数可以改变位置指针，其原型如下：\n\n```c\nint fseek(FILE *fp, long int offset, int from);\n```\n\n该函数可以将文件位置从`from`开始移动`offset`个字节。执行成功返回`0`，不成功返回非零值。\n\n其中，\n\n`fp`为文件指针；\n\n`offset`为移动的字节数，当其为正数时表示向末尾移动，负数表示向前移动，且必须为长整形数；\n\n`from`为起始位置，他的取值如下：\n\n| 常量     | 等效数字 | 描述               |\n| :------- | -------- | :----------------- |\n| SEEK_SET | 0        | 文件的开头         |\n| SEEK_CUR | 1        | 文件指针的当前位置 |\n| SEEK_END | 2        | 文件的末尾         |\n\nExample：\n\n```c\n#include <stdio.h>\n\nint main ()\n{\n   FILE *fp;\n   fp = fopen(\"file.txt\",\"w+\");\n   fputs(\"Lakphy YES!\", fp);\n   fseek( fp, 7, SEEK_SET );\n   fputs(\" C Programming Langauge\", fp);\n   fclose(fp);\n   \n   return(0);\n}\n```\n\n\n\n## ftell() 获取文件位置指针相对于文件头的位置\n\n该函数用于获取文件位置指针相对于文件头的位置，原型如下：\n\n```c\nlong int ftell(FILE *fp);\n```\n\n`fp`为文件指针，返回位置指针相对于文件头的偏移字节数，如果出错则返回`-1L`。\n\n\n\n## fflush() 刷新流 stream 的输出缓冲区\n\n通俗讲就是更新对文件的修改，其函数原型如下：\n\n```c\nint fflush(FILE *fp);\n```\n\n`fp`为文件指针。如果成功，该函数返回零值。如果发生错误，则返回 EOF，且设置错误标识符（即 feof）。\n\n\n\n## feof() 测试给定流 stream 的文件结束标识符\n\n该函数用于检测文件的位置指针是否到达文件末尾，其原型如下：\n\n```c\nint feof(FILE *stream);\n```\n\n`fp`为文件指针。到达文件末尾时返回非零值，否则返回0。\n\n\n\n## freopen() \n\n该函数用于把一个新的文件名 filename 与给定的打开的流 stream 关联，同时关闭流中的旧文件。通常用于将输入输出重定向到文件。其原型如下：\n\n```c\nFILE *freopen(const char *filename, const char *mode, FILE *stream);\n```\n\n`filename`字符串包含了要打开文件的名称；\n\n`stream`是指向 FILE 对象的指针，该 FILE 对象标识了要被重新打开的流。当其为`stdout`时为将输出重定向到文件，当其为`stdin`时为重定向输入到文件。\n\n`mode`为字符串，表示文件访问模式，与`fopen`用法一样。\n\n返回值：如果文件成功打开，则函数返回一个指针，指向用于标识流的对象。否则，返回空指针。\n\nExample:\n\n```c\nfp = freopen(\"file.txt\", \"w+\", stdout);\n```\n\n\n\n## remove() 删除文件\n\n该函数用于删除给定的文件名 `filename`，以便它不再被访问。其原型如下：\n\n```c\nint remove(const char *filename);\n```\n\n`filename`表示文件地址，数据类型为字符串，允许使用相对地址或绝对地址。例如在Windows系统下`\"D:\\\\data\\\\file.txt\"`可以用来表示地址，在Linux系统下`\"/mnt/test.txt\"`可以用来表示地址.\n\n如果成功，则返回零。如果错误，则返回 -1，并设置 errno。\n\n\n\n## rename() 重命名/移动文件\n\n该函数用于把 `old_filename` 所指向的文件名改为 `new_filename`。可以实现文件重命名/移动。其原型如下：\n\n```c\nint rename(const char *old_filename, const char *new_filename);\n```\n\n其中，\n\n`old_filename`为要重命名的文件名；\n\n`new_filename`为新的文件名。\n\n如果成功，则返回零。如果错误，则返回 -1，并设置 errno。","tags":["C语言"]},{"title":"在stm32单片机上使用printf","url":"/blog/2020/11/19/在stm32单片机上使用printf/","content":"\n对于C语言的初学者来说，最熟悉的大概是printf输出函数了，STM32单片机一般使用C语言编程，那么如何在STM32单片机中使用printf呢\n\n# 准备工作\n\n## 硬件\n\n这里使用STM32F401CCUx作为演示\n\njlink——用于烧录单片机以及串口通信测试\n\n## 软件\n\nSTM32CubeMX\n\nKeil\n\n（基于HAL库进行开发）\n\n串口调试助手\n\n### 关于串口调试助手\n\n串口调试助手建议下载微软应用商店里的，名字就是叫串口调试助手\n\n![image-20201119081033946](./image-20201119081033946.png)\n\n图标就是这个样子\n\n#### FAQ\n\n- 为什么我的微软应用商店打不开？\n\n- 因为种种我也不知道什么原因，微软的服务器在部分网咯下访问速度十分缓慢（装vs2019的小盆友应该能够感受到，所以建议使用手机热点开流量下载，这样会快一些\n\n  \n\n# 开始~~抄代码~~配置您的printf函数\n\n## 背景知识\n\n在stm32单片机中，printf函数是无法打印到控制台的。为了让这个函数能实现打印功能，我们必须要把这个函数重定向，让它重定向到串口中，把要输出的内容打印到串口中。为此需要以下几步。\n\n## 新建一个工程\n\n（老玩家请跳过）\n\n首先打开STM32CubeMX\n\n![image-20201119081658850](./image-20201119081658850.png)\n\n点击画圈部分新建一个工程\n\n![image-20201119081804461](./image-20201119081804461.png)\n\n选择我们要用的开发板STM32F401CCUx\n\n![image-20201119082114912](./image-20201119082114912.png)\n\n之后开始配置时钟\n\n先打开高速陶瓷晶振\n\n![image-20201119083719006](./image-20201119083719006.png)\n\n找到上方的Clock Configuration\n\n配置时钟，配置成果如图\n\n![image-20201119083907695](./image-20201119083907695.png)\n\n## 配置串口\n\n打开它的1号串口（请确保您的PA9和PA10引脚未被占用，后面会作说明）\n\n![image-20201119082402308](./image-20201119082402308.png)\n\n之后您会在右边的芯片示意图上看到串口1的引脚被占用，表示串口1已开启\n\n![image-20201119082612484](./image-20201119082612484.png)\n\n即可知PA9和PA10为串口1的引脚，PA9为TX，PA10为RX，请记住这个引脚名，之后需要使用\n\n可以在界面的中间下部看到串口1的控制台\n\n![image-20201119082859857](./image-20201119082859857.png)\n\n这里对控制台的一些基本设置做出解释，之后做串口通信时您需要对这些数据进行统一，否则会有非常鬼畜的现象（\n\n| 名称        | 用途                                   |\n| ----------- | -------------------------------------- |\n| Baud Rate   | 波特率，一般都为115200，有时也有用9600 |\n| Word Length | 数据位，一般为8                        |\n| Parity      | 校验位，一般为None                     |\n| Stop Bits   | 停止位，一般为1，有的地方称为One       |\n\n我们这里全部使用默认参数配置\n\n## 代码\n\n完成以上配置之后\n\n进入上方标签的project manager\n\n设置project name和project location\n\n之后找到这个东西\n\n![image-20201119084245670](./image-20201119084245670.png)\n\n改成![image-20201119084301138](./image-20201119084301138.png)\n\n点击右上角GENERATE CODE\n\n![image-20201119084050798](./image-20201119084050798.png)\n\n完成之后点击open project，在keil中打开项目\n\n打开main.c，在这个绿色位置\n\n![image-20201119101532465](./image-20201119101532465.png)\n\n准备插入代码，这里说明一下，在使用CubeMX做开发时，我们的代码要写在注释USER CODE BEGIN和USER CODE END位置，防止下次更新代被覆盖\n\n我们继续下一步操作，在上面说的位置插入代码\n\n```c\n#include \"stdio.h\"\n#ifdef __GNUC__\n#define PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f)\n#else\n#define PUTCHAR_PROTOTYPE int __io_putchar(int ch)\n#endif\nPUTCHAR_PROTOTYPE\n{\n    HAL_UART_Transmit(&huart1, (uint8_t *)&ch, 1 , 0xffff);\n    return ch;\n}\n```\n\n此代码将printf重定向到串口输出\n\n至此，~~教程结束~~\n\n# 测试\n\n## 代码\n\n在main.c的主函数main()里面有一段这样的代码\n\n![image-20201119085407904](./image-20201119085407904.png)\n\n我们在USER CODE END WHILE之前写我们的测试代码\n\n举个栗子\n\n```c\nprintf(\"Lakphy\");\nHAL_Delay(500);\n```\n\n这里的HAL_Delay是加一个延迟，防止串口通信频率太高卡死\n\n就是酱紫\n\n![image-20201119101703801](./image-20201119101703801.png)\n\n## 接线\n\n这里给出jlink接线方式\n\n下面是烧写程序用的\n\n| jlink | stm32 |\n| ----- | ----- |\n| GND   | GND   |\n| 3.3V  | 3V3   |\n| CLK   | SCK   |\n| SWO   | DIO   |\n\n下面是串口通信用的\n\n| jlink | stm32 | 意义 |\n| ----- | ----- | ---- |\n| TXD   | PA10  | RX   |\n| RXD   | PA9   | TX   |\n\n亲测可以同时接在一起，没有任何问题\n\n实物图\n\n![1605751787507](./1605751787507.jpg)\n\n## 烧录\n\n先进行一些必要的设置\n\n![image-20201119102121174](./image-20201119102121174.png)\n\n这一排东西\n\n找到\n\n![image-20201119102146596](./image-20201119102146596.png)\n\n这个按钮\n\n点击进入options\n\n![image-20201119102221026](./image-20201119102221026.png)这里，改一下\n\n改成这样（本来是可选操作的，但后面有操作需要它，所以这里都改成6.14吧）\n\n![image-20201119102546026](./image-20201119102546026.png)\n\n可以明显提升编译速度\n\n看见这一排没有\n\n![image-20201119102626917](./image-20201119102626917.png)\n\n点Debug，找到这里\n\n![image-20201119102648641](./image-20201119102648641.png)\n\n改成我们的jlink\n\n![image-20201119102704659](./image-20201119102704659.png)\n\n然后点下面的ok保存设置\n\n看到左上角一排按键有没有\n\n![image-20201119101730251](./image-20201119101730251.png)\n\n再放大\n\n![image-20201119101752181](./image-20201119101752181.png)\n\n左数第二个是编译，第三个是全部编译，右数第一个是烧录\n\n一般第一次打开项目或者你出现莫名其妙bug时候都要用全部编译，其他都是直接编译就行了。如果不怕费时间直接每次都全部编译也没有问题（\n\n编译之后下面显示类似这样表示编译正常，没有错误\n\n![image-20201119102911942](./image-20201119102911942.png)\n\n重点是这个\n\n![image-20201119102929897](./image-20201119102929897.png)\n\n~~众所周知 Warnings都没啥用~~\n\n然后点烧录\n\n![image-20201119103101164](./image-20201119103101164.png)\n\n可能提示这个\n\n![image-20201119103224227](./image-20201119103224227.png)\n\n不理会\n\n​\t然后看到下面这个\n\n![image-20201119103250347](./image-20201119103250347.png)\n\n继续等待\n\n出现这个\n\n![image-20201119103316615](./image-20201119103316615.png)\n\n表明烧录成功\n\n## 观察实验现象\n\n不要断开jlink，打开串口调试助手\n\n回忆我们之前在CubeMX做的配置\n\n![image-20201119082859857](./image-20201119082859857.png)\n\n将其应用到串口调试助手\n\n![image-20201119113849949](./image-20201119113849949.png)\n\n这样\n\n发现我们的参数和串口调试助手默认的一样，所以本次实验可以直接打开串口，无需配置\n\n点击打开串口，可以看到右侧输出我们的printf内容\n\n![image-20201119114159068](./image-20201119114159068.png)\n\n# 结尾\n\n至此教程结束\n\n有兴趣小盆友可以根据我之前的代码研究一下HAL库的串口通信函数，自己实现一个scanf","tags":["STM32单片机"]},{"title":"STM32外接DAC模块MCP4725","url":"/blog/2020/10/31/STM32外接DAC模块MCP4725/","content":"我最近在使用STM32F411CEU最小系统板做开发，但发现它并不自带DAC数模转换模块，所以我选择外接DAC模块MCP4725\n\n## 准备材料\n\n#### STM32系列开发板\n我这里对MCP4725的使用方法理论上都是通用的，所以对芯片的要求并不严格。\n我使用STM32F411CEU\n它拥有最高100MHz的主频，[官方文档](https://www.st.com/resource/en/reference_manual/dm00119316-stm32f411xc-e-advanced-arm-based-32-bit-mcus-stmicroelectronics.pdf)\n![STM32F411CEU](1.jpg)\n\n### MCP4725数模转换模块\nMCP4725价格低廉，使用I2C接口（拉了拉了）\n[官方文档](http://ww1.microchip.com/downloads/en/devicedoc/22039d.pdf)\n![MCP4725 Breakout](2.jpg)\n\n### 面包板杜邦线若干\n众所周知，杜邦线是会自己消失的\n\n## 代码\n在cubemx中打开I2C接口\n在项目文件夹内`/Core/lnc/`内建立文件`MCP4725.h`，代码如下\n```c\n//MCP4725 Driver\n#ifndef INC_MCP4725_H_\n#define INC_MCP4725_H_\n\n#include \"stdint.h\"\n#include \"stm32f4xx_hal.h\"\n\n#define MCP4725_ADDRESS     0xc0\n#define MCP4725_READ        0x01\n#define MCP4725_DAC         0x40\n#define MCP4725_DAC_EEPROM  0x60\n\nvoid MCP4725_Out(I2C_HandleTypeDef *hi2c,uint16_t outputValue,uint8_t writeMode);\n\n#endif /* INC_MCP4725_H_ */\n```\n这里需要注意一下，根据官方文档，为了使一块板子上可以使用更多个MCP4725，MCP4725的A0引脚可以选择上拉或者下拉，当下拉时，MCP4725的地址为0x60，上拉时为0x61，不拉时默认下拉。我这里使用默认下拉0x60地址，抄代码时请按需修改。\n在项目文件夹内`/Core/Src/`内建立文件`MCP4725.c`，代码如下\n```c\n//MCP4725 Driver\n\n#include \"MCP4725.h\"\n#include \"stdint.h\"\n\nvoid MCP4725_Out(I2C_HandleTypeDef *hi2c,uint16_t outputValue,uint8_t writeMode){\n    uint8_t buffer[3]={0x00};\n\t\tuint32_t flag=0;\n    if(writeMode==1){\n        buffer[0]=MCP4725_DAC_EEPROM;\n    }\n    else{\n        buffer[0]=MCP4725_DAC;\n    }\n\toutputValue=outputValue * 4096 / 3300.0f;//3300表示标准电压3.3v，按需修改\n    buffer[1]=(outputValue/16);\n    buffer[2]=(outputValue%16)<<4;\n\n    flag=HAL_I2C_Master_Transmit(hi2c,MCP4725_ADDRESS,buffer,3,1000);\n\n    HAL_Delay(1);\n}\n```\n下一步在主函数中做出修改\n加入头文件\n```c\n#include \"MCP4725.h\"\n#include \"MCP4725.c\"\n```\n调用实例\n```c\nMCP4725_Out(&hi2c1,2000,1)//在i2c1接口的MCP4725上输出2000mv电压\n```\n\n## 总结\n这款MCP4725模块价格实惠，但i2c接口实在拉跨。以上教程实现了傻瓜式调用，总结一句就是\n> 有手就行","tags":["STM32单片机"]},{"title":"OI心(wu)得(dao)","url":"/blog/2020/10/06/oi心得/","content":"还有几天就是2020年NOIp初赛了，想起来我都快有两年没打OI了，这里分享一点小小的oi心(wu)得(dao)\n\n---\n\n模拟只会猜题意,贪心只能过样例; 数学上来先打表,\n\nDP一般看规律. 组合数学靠运气,计算几何瞎暴力;\n\n图论强行套模板,数论只会GCD.\n\n递归递推伤不起,搜索茫然TLE;\n\n分治做得像枚举,暴力枚举数第一.\n\n数据结构干瞪眼,怒刷水题找信心;\n\n涨姿势也不容易,考试一来全懵逼!\n\n---\n\nAC: Answer Correct 正确的答案\n\nCE:Compile Easily 轻松地通过编译\n\nPC: Pass Compile 通过编译\n\nWA:Wonerful Answer 极好的答案\n\nRE:Right Enough 过于正确\n\nTLE: Time Limit Enough 时间充裕\n\nMLE: Memory Limit Enough 内存充裕\n\nOLE: Output Limit Enough 输出充裕\n\nUKE: Unknown Exactness 不明情况的正确\n\n---\n\n骗分过样例， 暴力出奇迹。 数学先打表， ＤＰ看运气。\n\n穷举ＴＬＥ， 递推ＵＫＥ。 模拟ＭＬＥ， 贪心还ＣＥ。\n\n想要骗到分， 就要有方法。 图论背模板， 数论背公式。\n\n动规背方程， 高精背代码。 如果都没背， 干脆输样例。\n\n---\n\n![](oi.gif)","tags":["OI"]},{"title":"Arduino鬼畜电子琴制作","url":"/blog/2020/10/04/Arduino鬼畜电子琴制作/","content":"由于某些原因，我又拿出了我的Arduino开发板，这次准备制作一个完整的电子琴。没有意外的话，这应该是我最后一次做Arduino了。\n# 正式开始前的准备\n### 明确需求\n1. 能演奏基本音符\n2. 能演奏高低音\n3. 能通过显示设备输出当前音符\n4. 能够自动演奏\n\n### 硬件准备\n\n#### 开发板\n这次仍然采用经典的 Arduino Uno 开发板，相关说明在我之前的博客中有提及，这里不做描述。\n\n#### 发声设备\n为便于研究(lan)，这次采用的是无源蜂鸣器作为发声设备，同样，我在之前博客中有提及，这里不描述。\n\n#### 显示设备\n我的显示设备采用LCD 1602，使用spi接口，可以大幅降低成本（但会占用大量GPIO）\n![LCD 1602](1.jpg)\n\n#### 其他\n1. 杜邦线若干（众所周知，杜邦线是会自己消失的 /确信）\n2. 适量面包板\n3. 10个10k欧电阻（用于制作下拉电路）\n4. 11个按键\n\n# 制作\n\n### 绘制电路图\n\n#### 工具\n我使用[fritzing](https://fritzing.org/)制作电路图\n\n#### LCD1602接线\n为节约GPIO，我采用四线接法，为方便接线，我把六根线全挂在An GPIO上面，接线表如下\n\n| LCD1602 | PIN |\n| ------------: | :------------ |\n| VSS      | GND           |\n| VDD      | 5V            |\n| V0       | 电位器中间引脚 |\n| RS       | A0            |\n| RW       | GND           |\n| E        | A1            |\n| D0       | /             |\n| D1       | /             |\n| D2       | /             |\n| D3       | /             |\n| D4       | A2            |\n| D5       | A3            |\n| D6       | A4            |\n| D7       | A5            |\n| A        | 5V            |\n| K        | GND           |\n\n#### 关于开关按键的电路\n经过我的多次实践发现，若按键直接接INPUT接口，且开发板上接有无源蜂鸣器，会出现按键莫名改变状态的问题。\n经过约一周的收集资料及咨询大佬，终于发现了问题。\n问题关键是INPUT接口的高低电平不确定。目前存在两种解决方案：\n1. 设置芯片INPUT接口内部上拉\n2. 在按键外部部分设置外部下拉电路\n\n##### 方案一 内部上拉\n故名思意，内部上拉，就是在芯片内部将这个GPIO的电平调至高电平，先不管芯片内部是怎么实现的这一功能，对于我们来说，这个功能只需要一行代码就能解决，所以这是最简单的解决方案。\n代码说明：\n原来的INPUT接口初始化代码如下\n```C++\npinMode(11, INPUT);\n```\n我们现在要将其改为\n```c++\npinMode(11, INPUT_PULLUP);\n```\n即可实现内部上拉。\n但因为我可能在某宝买到了假的Uno开发板，我没能实现内部上拉，所以我选择了外部下拉。\n\n##### 方案二 外部下拉\n既然是外部，电路自然不同，原本的开关电路将要改成下图样式\n![外部下拉电路简图](2.jpg)\n以咱可怜的高中物理水平就不强行解释这个电路原理了（\n\n#### 成果图\n![成果电路图](3.jpg)\n\n### 采购元件\n这里推荐淘宝上的优信电子\n\n### 代码部分\n我需要先定义各个音符及其高低音的发声频率\n```c++\n#define Do_l 262\n#define re_l 294\n#define mi_l 330\n#define fa_l 349\n#define so_l 392\n#define la_l 440\n#define si_l 494\n#define Do 523\n#define re 587\n#define mi 659\n#define fa 698\n#define so 784\n#define la 880\n#define si 932\n#define Do_h 1046\n#define re_h 1175\n#define mi_h 1318\n#define fa_h 1397\n#define so_h 1568\n#define la_h 1760\n#define si_h 1976\n```\n然后开始制作标准音及混音发声\n目前我找到了一个很难受的土制混音方案，就是每隔一毫秒换一次音，缺点就是声音很沙哑，有点抖。\n为实现无限叠加混音，我使用了如下代码\n```c++\n    while (1) {\n      int normalTones[8] = {};\n      int num = 0;\n      //get button state\n      button0 = digitalRead(2);\n      button1 = digitalRead(3);\n      button2 = digitalRead(4);\n      button3 = digitalRead(5);\n      button4 = digitalRead(6);\n      button5 = digitalRead(7);\n      button6 = digitalRead(8);\n      button7 = digitalRead(9);\n      button8 = digitalRead(10);\n      button9 = digitalRead(11);\n      if (button0 == HIGH) {\n        normalTones[num] = Do;\n        num++;\n      }\n      if (button1 == HIGH) {\n        normalTones[num] = re;\n        num++;\n      }\n      if (button2 == HIGH) {\n        normalTones[num] = mi;\n        num++;\n      }\n      if (button3 == HIGH) {\n        normalTones[num] = fa;\n        num++;\n      }\n      if (button4 == HIGH) {\n        normalTones[num] = so;\n        num++;\n      }\n      if (button5 == HIGH) {\n        normalTones[num] = la;\n        num++;\n      }\n      if (button6 == HIGH) {\n        normalTones[num] = si;\n        num++;\n      }\n      normalTones[num] = 0;\n      if (num == 0) {\n        //lcd print\n        lcd.setCursor(0, 1);\n        lcd.print(\"Welcome!        \");\n      }\n      else if (num == 1) {\n        if (normalTones[0] == Do) {\n          //lcd print\n          lcd.setCursor(0, 1);\n          lcd.print(\"Do (C)          \");\n        }\n        else if (normalTones[0] == re) {\n          //lcd print\n          lcd.setCursor(0, 1);\n          lcd.print(\"Re (D)          \");\n        }\n        else if (normalTones[0] == mi) {\n          //lcd print\n          lcd.setCursor(0, 1);\n          lcd.print(\"Mi (E)          \");\n        }\n        else if (normalTones[0] == fa) {\n          //lcd print\n          lcd.setCursor(0, 1);\n          lcd.print(\"Fa (F)          \");\n        }\n        else if (normalTones[0] == so) {\n          //lcd print\n          lcd.setCursor(0, 1);\n          lcd.print(\"So (G)          \");\n        }\n        else if (normalTones[0] == la) {\n          //lcd print\n          lcd.setCursor(0, 1);\n          lcd.print(\"La (A)          \");\n        }\n        else if (normalTones[0] == si) {\n          //lcd print\n          lcd.setCursor(0, 1);\n          lcd.print(\"Si (B)          \");\n        }\n      }\n      else{\n          //lcd print\n          lcd.setCursor(0, 1);\n          lcd.print(\"MIX             \");\n      }\n      for (int i = 0; i < 8; i++) {\n        if (normalTones[i] == 0) break;\n        tone(13, normalTones[i]);\n        delay(1);\n      }\n      if (num == 0) break;\n    }\n```\n这里说明一下几个函数\n```c++\nlcd.setCursor(0, 1);//设置打印字符光标位置为第二行第一个\nlcd.print();//打印括号内的字符\ndelay(1);//延时1ms\ntone();//发声函数，需要传递两个参数，一个参数为发声脚，一个为频率\ndigitalRead();//获取按键状态，当被按下时为HIGH\n```\n\n### 完整代码\n```c++\n#include <LiquidCrystal.h>\n/*\nThis programme was produced by Lakphy.\nIt is prohibited to use these code for illegal purposes.\nWelcome to visit the private site of Lakphy:\nInternational channel: lakphy.me\n        China channel: lakphy.gitee.io\n                Email: lakphy@outlook.com\nThanks for the help of the seniors of SAST !\nThanks for open source ! \n*/\n#define Do_l 262\n#define re_l 294\n#define mi_l 330\n#define fa_l 349\n#define so_l 392\n#define la_l 440\n#define si_l 494\n#define Do 523\n#define re 587\n#define mi 659\n#define fa 698\n#define so 784\n#define la 880\n#define si 932\n#define Do_h 1046\n#define re_h 1175\n#define mi_h 1318\n#define fa_h 1397\n#define so_h 1568\n#define la_h 1760\n#define si_h 1976\n// vss   vcc   v0   rs   rw   e   db0   db1   db2   db3   db4   db5   db6   db7   led+   led-\n//                  a0        a1  \\     \\     \\     \\     A2    A3    A4    A5\nint button0 = LOW;\nint button1 = LOW;\nint button2 = LOW;\nint button3 = LOW;\nint button4 = LOW;\nint button5 = LOW;\nint button6 = LOW;\nint button7 = LOW;\nint button8 = LOW;\nint button9 = LOW;\nLiquidCrystal lcd(A0, A1, A2, A3, A4, A5);\nint music[] = {\n  so_l, so_l, la_l, so_l, Do  , si_l,\n  so_l, so_l, la_l, so_l, re  , Do  ,\n  so_l, so_l, so  , mi  , Do  , si_l, so_l,\n  fa  , fa  , mi  , Do  , re  , Do\n};\nint times[] = {\n  200, 200, 400, 400, 400, 800,\n  200, 200, 400, 400, 400, 800,\n  400, 400, 400, 400, 400, 400, 400,\n  400, 200, 400, 400, 400, 800\n};\nvoid setup() {\n  // setup lcd\n  lcd.begin(16, 2);\n  lcd.print(\"Lakphy Singer :)\");\n  lcd.setCursor(0, 1);\n  lcd.print(\"Hello!          \");\n  // setup keyboard\n  pinMode(2, INPUT);\n  pinMode(3, INPUT);\n  pinMode(4, INPUT);\n  pinMode(5, INPUT);\n  pinMode(6, INPUT);\n  pinMode(7, INPUT);\n  pinMode(8, INPUT);\n  pinMode(9, INPUT);\n  pinMode(10, INPUT);\n  pinMode(11, INPUT);\n  //setup tones\n  pinMode(13, OUTPUT);\n  noTone(13);\n}\n\nvoid loop() {\n  bool canRun = 1;\n  //get button state\n  button0 = digitalRead(2);\n  button1 = digitalRead(3);\n  button2 = digitalRead(4);\n  button3 = digitalRead(5);\n  button4 = digitalRead(6);\n  button5 = digitalRead(7);\n  button6 = digitalRead(8);\n  button7 = digitalRead(9);\n  button8 = digitalRead(10);\n  button9 = digitalRead(11);\n\n  //high\n  if (button7 == HIGH) {\n\n    if (button0 == HIGH) {\n      //lcd print\n      lcd.setCursor(0, 1);\n      lcd.print(\"Do_h (C)        \");\n      //sing\n      tone(13, Do_h);\n      delay(50);\n      while (1) {\n        if (digitalRead(2) != HIGH) break;\n        delay(10);\n      }\n      noTone(13);\n    }\n    //re\n    if (button1 == HIGH) {\n      //lcd print\n      lcd.setCursor(0, 1);\n      lcd.print(\"Re_h (D)        \");\n      tone(13, re_h);\n      delay(50);\n      while (1) {\n        if (digitalRead(3) != HIGH) break;\n        delay(10);\n      }\n      noTone(13);\n    }\n    //mi\n    if (button2 == HIGH) {\n      //lcd print\n      lcd.setCursor(0, 1);\n      lcd.print(\"Mi_h (E)        \");\n      tone(13, mi_h);\n      delay(50);\n      while (1) {\n        if (digitalRead(4) != HIGH) break;\n        delay(10);\n      }\n      noTone(13);\n    }\n    //fa\n    if (button3 == HIGH) {\n      //lcd print\n      lcd.setCursor(0, 1);\n      lcd.print(\"Fa_h (F)        \");\n      tone(13, fa_h);\n      delay(50);\n      while (1) {\n        if (digitalRead(5) != HIGH) break;\n        delay(10);\n      }\n      noTone(13);\n    }\n    //so\n    if (button4 == HIGH) {\n      //lcd print\n      lcd.setCursor(0, 1);\n      lcd.print(\"So_h (G)        \");\n      tone(13, so_h);\n      delay(50);\n      while (1) {\n        if (digitalRead(6) != HIGH) break;\n        delay(10);\n      }\n      noTone(13);\n    }\n    //la\n    if (button5 == HIGH) {\n      //lcd print\n      lcd.setCursor(0, 1);\n      lcd.print(\"La_h (A)        \");\n      tone(13, la_h);\n      delay(50);\n      while (1) {\n        if (digitalRead(7) != HIGH) break;\n        delay(10);\n      }\n      noTone(13);\n    }\n    //si\n    if (button6 == HIGH) {\n      //lcd print\n      lcd.setCursor(0, 1);\n      lcd.print(\"Si_h (B)        \");\n      tone(13, si_h);\n      delay(50);\n      while (1) {\n        if (digitalRead(8) != HIGH) break;\n        delay(10);\n      }\n      noTone(13);\n    }\n  }\n\n  //low\n  else if (button8 == HIGH) {\n\n    if (button0 == HIGH) {\n      //lcd print\n      lcd.setCursor(0, 1);\n      lcd.print(\"Do_l (C)        \");\n      //sing\n      tone(13, Do_l);\n      delay(50);\n      while (1) {\n        if (digitalRead(2) != HIGH) break;\n        delay(10);\n      }\n      noTone(13);\n    }\n    //re\n    if (button1 == HIGH) {\n      //lcd print\n      lcd.setCursor(0, 1);\n      lcd.print(\"Re_l (D)        \");\n      tone(13, re_l);\n      delay(50);\n      while (1) {\n        if (digitalRead(3) != HIGH) break;\n        delay(10);\n      }\n      noTone(13);\n    }\n    //mi\n    if (button2 == HIGH) {\n      //lcd print\n      lcd.setCursor(0, 1);\n      lcd.print(\"Mi_l (E)        \");\n      tone(13, mi_l);\n      delay(50);\n      while (1) {\n        if (digitalRead(4) != HIGH) break;\n        delay(10);\n      }\n      noTone(13);\n    }\n    //fa\n    if (button3 == HIGH) {\n      //lcd print\n      lcd.setCursor(0, 1);\n      lcd.print(\"Fa_l (F)        \");\n      tone(13, fa_l);\n      delay(50);\n      while (1) {\n        if (digitalRead(5) != HIGH) break;\n        delay(10);\n      }\n      noTone(13);\n    }\n    //so\n    if (button4 == HIGH) {\n      //lcd print\n      lcd.setCursor(0, 1);\n      lcd.print(\"So_l (G)        \");\n      tone(13, so_l);\n      delay(50);\n      while (1) {\n        if (digitalRead(6) != HIGH) break;\n        delay(10);\n      }\n      noTone(13);\n    }\n    //la\n    if (button5 == HIGH) {\n      //lcd print\n      lcd.setCursor(0, 1);\n      lcd.print(\"La_l (A)        \");\n      tone(13, la_l);\n      delay(50);\n      while (1) {\n        if (digitalRead(7) != HIGH) break;\n        delay(10);\n      }\n      noTone(13);\n    }\n    //si\n    if (button6 == HIGH) {\n      //lcd print\n      lcd.setCursor(0, 1);\n      lcd.print(\"Si_l (B)        \");\n      tone(13, si_l);\n      delay(50);\n      while (1) {\n        if (digitalRead(8) != HIGH) break;\n        delay(10);\n      }\n      noTone(13);\n    }\n  }\n  else if (button9 == HIGH) {\n    if (canRun) {\n      //lcd print\n      lcd.setCursor(0, 1);\n      lcd.print(\"Auto Singing....\");\n      for (int x = 0; x < 25; x++)\n      {\n        if (!canRun) break;\n        if (music[x] == 0) {\n          noTone(13);\n        }\n        else {\n          tone(13, music[x]);\n        }\n        delay(times[x]);//节拍延时\n        //digitalWrite(ledpin,LOW);\n        noTone(13);\n      }\n      canRun = 0;\n    }\n    //lcd print\n    lcd.setCursor(0, 1);\n    lcd.print(\"Singing END !   \");\n  }\n  //\n  //\n  //\n  //normal tone\n  /*\n    //Do\n    else if (button0 == HIGH) {\n    //lcd print\n    lcd.setCursor(0, 1);\n    lcd.print(\"Do (C)          \");\n    //sing\n    tone(13, Do);\n    delay(50);\n    while (1) {\n      if (digitalRead(2) != HIGH) break;\n      delay(10);\n    }\n    noTone(13);\n    }\n    //re\n    else if (button1 == HIGH) {\n    //lcd print\n    lcd.setCursor(0, 1);\n    lcd.print(\"Re (D)          \");\n    tone(13, re);\n    delay(50);\n    while (1) {\n      if (digitalRead(3) != HIGH) break;\n      delay(10);\n    }\n    noTone(13);\n    }\n    //mi\n    else if (button2 == HIGH) {\n    //lcd print\n    lcd.setCursor(0, 1);\n    lcd.print(\"Mi (E)          \");\n    tone(13, mi);\n    delay(50);\n    while (1) {\n      if (digitalRead(4) != HIGH) break;\n      delay(10);\n    }\n    noTone(13);\n    }\n    //fa\n    else if (button3 == HIGH) {\n    //lcd print\n    lcd.setCursor(0, 1);\n    lcd.print(\"Fa (F)          \");\n    tone(13, fa);\n    delay(50);\n    while (1) {\n      if (digitalRead(5) != HIGH) break;\n      delay(10);\n    }\n    noTone(13);\n    }\n    //so\n    else if (button4 == HIGH) {\n    //lcd print\n    lcd.setCursor(0, 1);\n    lcd.print(\"So (G)          \");\n    tone(13, so);\n    delay(50);\n    while (1) {\n      if (digitalRead(6) != HIGH) break;\n      delay(10);\n    }\n    noTone(13);\n    }\n    //la\n    else if (button5 == HIGH) {\n    //lcd print\n    lcd.setCursor(0, 1);\n    lcd.print(\"La (A)          \");\n    tone(13, la);\n    delay(50);\n    while (1) {\n      if (digitalRead(7) != HIGH) break;\n      delay(10);\n    }\n    noTone(13);\n    }\n    //si\n    else if (button6 == HIGH) {\n    //lcd print\n    lcd.setCursor(0, 1);\n    lcd.print(\"Si (B)          \");\n    tone(13, si);\n    delay(50);\n    while (1) {\n      if (digitalRead(8) != HIGH) break;\n      delay(10);\n    }\n    noTone(13);\n    }\n  */\n  else {\n    while (1) {\n      int normalTones[8] = {};\n      int num = 0;\n      //get button state\n      button0 = digitalRead(2);\n      button1 = digitalRead(3);\n      button2 = digitalRead(4);\n      button3 = digitalRead(5);\n      button4 = digitalRead(6);\n      button5 = digitalRead(7);\n      button6 = digitalRead(8);\n      button7 = digitalRead(9);\n      button8 = digitalRead(10);\n      button9 = digitalRead(11);\n      if (button0 == HIGH) {\n        normalTones[num] = Do;\n        num++;\n      }\n      if (button1 == HIGH) {\n        normalTones[num] = re;\n        num++;\n      }\n      if (button2 == HIGH) {\n        normalTones[num] = mi;\n        num++;\n      }\n      if (button3 == HIGH) {\n        normalTones[num] = fa;\n        num++;\n      }\n      if (button4 == HIGH) {\n        normalTones[num] = so;\n        num++;\n      }\n      if (button5 == HIGH) {\n        normalTones[num] = la;\n        num++;\n      }\n      if (button6 == HIGH) {\n        normalTones[num] = si;\n        num++;\n      }\n      normalTones[num] = 0;\n      if (num == 0) {\n        //lcd print\n        lcd.setCursor(0, 1);\n        lcd.print(\"Welcome!        \");\n      }\n      else if (num == 1) {\n        if (normalTones[0] == Do) {\n          //lcd print\n          lcd.setCursor(0, 1);\n          lcd.print(\"Do (C)          \");\n        }\n        else if (normalTones[0] == re) {\n          //lcd print\n          lcd.setCursor(0, 1);\n          lcd.print(\"Re (D)          \");\n        }\n        else if (normalTones[0] == mi) {\n          //lcd print\n          lcd.setCursor(0, 1);\n          lcd.print(\"Mi (E)          \");\n        }\n        else if (normalTones[0] == fa) {\n          //lcd print\n          lcd.setCursor(0, 1);\n          lcd.print(\"Fa (F)          \");\n        }\n        else if (normalTones[0] == so) {\n          //lcd print\n          lcd.setCursor(0, 1);\n          lcd.print(\"So (G)          \");\n        }\n        else if (normalTones[0] == la) {\n          //lcd print\n          lcd.setCursor(0, 1);\n          lcd.print(\"La (A)          \");\n        }\n        else if (normalTones[0] == si) {\n          //lcd print\n          lcd.setCursor(0, 1);\n          lcd.print(\"Si (B)          \");\n        }\n      }\n      else{\n          //lcd print\n          lcd.setCursor(0, 1);\n          lcd.print(\"MIX             \");\n      }\n      for (int i = 0; i < 8; i++) {\n        if (normalTones[i] == 0) break;\n        tone(13, normalTones[i]);\n        delay(1);\n      }\n      if (num == 0) break;\n    }\n  }\n\n  //delay\n  noTone(13);\n}\n```\n\n# 成品图\n![成品图](singer.jpg)\n","tags":["Arduino"]},{"title":"联想 YOGA 14S 开箱评测","url":"/blog/2020/08/20/联想-YOGA-14S-开箱评测/","content":"\n联想YOGA 14S这款电脑被联想鸽了又鸽，改了又改，但性价比还是很高，我于八月初买了这台笔记本\n[京东链接](https://item.m.jd.com/product/53673115658.html?wxa_abtest=o&gx=RnFhkmFZaDGLy9RJ_t83BYE&ad_od=share&utm_source=androidapp&utm_medium=appshare&utm_campaign=t_335139774&utm_term=CopyURL\n)\n# 先说说外观\n这款笔记本的ACD面是金属的，很有质感，用起来相当舒服，虽说没有联想的yoga系列本应该有的高端血统，但明显比联想的低端小新系列要强很多\n\n180度展开图:\n![](2.jpg)\n这里说明一下，官方并没有说过这机器支持180度展开，所以能不能完全180度展开这完全看命了\n\nC面：键盘很有质感，很舒服\n![](3.jpg)\n\nB面显示屏：高色域 60Hz 1080p\n![](4.jpg)\n\nD面：\n![](5.jpg)\n\nA面\n![](6.jpg)\n\n侧面接口\n![](7.jpg)\n![](8.jpg)\n\n# 关于配置\n由于AMD的高性价比芯片，这款电脑整体性价比也非常高，我的购入价是5099，现在好像还涨价了\n\n### 芯片\n联想YOGA 14S采用AMD锐龙R7 4800U芯片，8核16线程，7nm制程，无论是参数还是跑分，都算得上是今年上半年最强低压U了吧\n8核16线程对我这种经常开一堆窗口的直男来说非常有用，7nm制程的耗电和发热都很低，就像我现在，用vscode码字，后台开文件管理器和chrome，D面基本感觉不到热，风扇我日常使用基本都不转。\n但也有一点小缺点，就是在某些不支持多核加速的编译器上，单核性能明显不足，不过既然都低压U轻薄本了，还在乎它的编译速度吗？\n\n### 显卡\n这款电脑使用的是集成显卡，显卡这方面确实拉跨，不过比英特尔的核显强这是肯定的，日常使用没啥问题，平时用ps时候偶尔会有些卡顿，玩游戏就。。。。\n不过作为一个八辈子不玩电脑游戏，玩电脑游戏就打开赛尔号的憨憨，这确实影响没多大影响，我还是觉得电脑游戏没啥意思，不是说觉得电脑游戏做的烂，主要没那感觉，没有手游或者switch玩的顺手，以后我要想打游戏就玩手游，或者攒钱买个破解版3ds也够，电脑还是感觉不舒服。\n\n### 内存\n16GB 双通道 32bit 4266MHz频率 LPDDR4 内存，感觉这个配置相当不错，毕竟AMD的芯片比较吃内存频率，比起隔壁华为的2666，提升的不是一点半点。\n\n### 硬盘\n512GB硬盘，这个据说和首发有出入，不过满足使用\n\n### 网卡\n支持Wifi6好评\n\n### 屏幕\n联想祖传高色域屏好评\n\n### 电源\n60wh能用8h以上，对我这种从来不插电的人来说很方便。\n使用65wPD快充，速度快，但发热比较大\n\n### 屏幕解锁\n这款电脑不支持指纹解锁，但支持Windows Hello面部识别，我觉得Windows Hello比指纹识别更好用，很多小细节做的不错，比如注视不锁屏、离开锁屏、人体感知，这些做的不错，总之就这么说吧，Windows Hello配合开盖开机，我几乎没按过电源键，全都是自动操作。\n\n\n# 实际体验\n使用体验很不错，但16:10屏幕的效率确实不高，有钱建议买华为祖传3:2高色域2k触屏，那个更舒服\n\n# 槽点\n### 品控辣鸡\n买之前就看见网上说品控不行，平均换货四五次，所以我从京东买的，毕竟京东售后比较好嘛\n我换了一次货，因为部分键位是坏的，再发来时候虽然也不怎么如意，但不影响使用我就没再计较，应该也是通病\n#### 1、转轴有点歪\n这个就是偶尔看的时候有点难受，勉强接受吧\n#### 2、屏幕油腻\n这个倒是通病，近看会有油腻感觉，远看不影响\n![](9.jpg)\n#### 3、键盘有磕碰\n这个应该是我这台自己问题了，但怕再换来问题更大的，就没换，反正不影响使用\n看图吧：\n![](10.jpg)\n#### 4、D面按压会响\n![](11.jpg)\n就是这种，按压会有响声\n#### 5、屏幕弯曲\n这个应该是磁吸合盖的锅，合上盖时候，屏幕中间上下可以贴死，但两侧会翘起来一点，就像一本用了很长时间的日记本中间用绳子绑起来一样\n\n# 结尾\n![](12.jpg)","tags":["开箱评测"]},{"title":"这个小米巨能写它香吗","url":"/blog/2020/03/21/这个小米巨能写它香吗/","content":"年前慕名买了一盒小米巨能写，小米之家现货一盒9.9十支，用来体验一下非常不错。\n如果像我一样只想体验一下的话建议线下小米之家买，因为线上两盒起购，邮费十元，实在太坑。\n# 先看看官方说明\n [小米商城链接](https://m.mi.com/commodity/detail/9836)\n其实也没什么，就是一直强调便宜，油墨好，墨量大，就这三点，这里不引用官网大篇幅海报了\n\n# 评测\n我已使用巨能写很长时间，下面说一下体验\n\n## 流畅度\n巨能写的流畅度做的很不错，虽然和日本中性笔相比相差十万八千里，但在国产五元以下中性笔里可以说是无敌了（当然这里不考虑晨光优品那种偏科生，偏的不是一般偏，没法用）。\n\n## 悬空漏墨\n就是说不盖笔帽，笔尖向下放置一段时间是否漏墨\n这个方面做得还不错，完胜三菱UM100。\n但是三菱UM100就这一个缺点啊。。。。。\n\n## 墨量\n巨能写出墨略微有些冲，和三菱UM100一个量级的出墨，这个我喜欢\n\n## 耐摔\n巨能写非常不耐摔，笔尖摔过以后出墨量以及流畅度都有不同程度的影响，这种影响取决于摔笔时的作用力\n\n# 书写比较\n这里看张图吧\n![](5.jpg)\n左列画圆圈对比\n中列书写对比\n右列墨水拖影对比\n\n这里科普一下，画圈圈对比是我长期使用三菱UM100总结出来的判断笔尖好坏的方法，三菱UM100众所周知一摔就坏，通过画圈圈的方法可以找到损坏位置，然后避免书写时用损坏处，可以延长坏笔寿命。\n还有墨水拖影这个是比较墨水色差，这个在百乐V系笔和三菱笔之间可以看出非常明显色差\n\n# 开箱图？\n![](2.jpg)\n![](3.jpg)\n![](1.jpg)\n![](4.jpg)\n\n# 总结\n小米巨能写性价比可以说无敌，但用途不广，它并不能替代我的三菱中性笔，尽管它足够便宜。它适用于对文字美观要求不高，对写字速度要求不高的场景，由于笔尖落后非常影响美观，另外使用时间长或者速度较快会有非常明显的疲劳感（官方说可以写一本圆周率，真是可怜小米实验室测试员工了）。在学习中，巨能写可以承担一些简单的工作，比如写练习册什么的，抄课文这个工程量大，会引起疲劳，如果财力不旺盛还是用巨能写好，但疲劳这个后果需要提前知道，另外考试可不能用巨能写，你的努力成果怎么能押在九毛九的笔身上，怎么说也得上个3块以上，我一般是5块的三菱um100（话说我刚入笔坑时候um100才3.5RMB啊）\n","tags":["中性笔"]},{"title":"muSpider__QQ音乐榜单下载器","url":"/blog/2020/03/20/muSpider__QQ音乐榜单下载器/","content":"\n# 关于muSpider\n\n这是一个QQ音乐榜单爬取程序\n\n包括付费音乐已经被隐藏的音乐，凡是在榜单上且QQ音乐服务器有存储的音乐都可以爬取\n\n破解了时间和数量的限制\n\n开源位置：\n\n[muSpider仓库](https://GitHub.com/lakphy/muSpider)\n\n声明： 仅供学习交流使用，转发请注明出处\n\n为保证所有使用者利益，请控制使用频率！！！\n\n## 目录\n - [快速开始](#快速开始)\n - [FAQ(常见问题及解答)](#faq常见问题及解答)\n - [可以爬取的榜单](#可以爬取的榜单)\n - [榜单适配进度](#榜单适配进度)\n - [参与适配榜单](#参与适配榜单)\n\n## 快速开始\n\n### 必要的准备\n\n环境：Python\n\n版本：>=3.5\n\n相关库安装：对于大部分用户，一般情况不需要安装多余的库\n\n若您使用过程中出现了因缺少库产生的问题，尝试在 shell / cmd / Powershell 中运行以下命令以安装缺少的库\n\n```shell\npip insatll urllib\npip insatll time\npip insatll requests\npip install sys\npip insatll os\npip insatll datetime\npip insatll random\npip insatll pip\n```\n\n### 开始运行\n\n前往[muSpider仓库](https://GitHub.com/lakphy/muSpider)下载仓库zip文件(或克隆仓库)并解压\n\n在文件所在目录打开 shell / cmd / Powershell 运行\n\n```\npython music.py\n```\n\n即可开始爬取QQ音乐榜单\n\n### 关于使用密码 (此功能已废除)\n\n为防止被搬运，软件内设有动态密码验证，变化周期为小时\n\n动态密码计算公式：\n\n```python\nkey = str(int(int(datetime.date.today().strftime('%y%m%d'))%10+(int(datetime.date.today().strftime('%y%m%d'))%1000-int(datetime.date.today().strftime('%y%m%d'))%100)/100+(int(datetime.date.today().strftime('%y%m%d'))%100000-first%10000)/10000))+str(datetime.datetime.now().hour%10)+str((int(datetime.date.today().strftime('%y%m%d'))%10+datetime.datetime.now().hour%10)%10)\n```\n\n公式解释：\n\n密码为三个数字的组合，中间无间隔；\n\n第一个数为 当前月份的个位数 + 当前日期的个位数 + 当前年份的个位数；\n\n第二个数为 当前小时数的个位数\n\n第三个数为 ( 当前小时的个位数 + 当前日期的个位数 ) 除以10的余数\n\n## FAQ(常见问题及解答)\n\n问：运行中间出现突然报错跳出？\n\n答：可能是因为代理服务器不稳定或者您的网络不稳定所致，建议检测网络并重新打开程序\n\n\n\n## 可以爬取的榜单\n\n- [x] 流行指数榜\n\n- [x] 欧美榜\n\n- [x] 内地榜\n\n- [x] iTunes榜\n\n- [x] 香港地区榜\n\n- [x] 台湾地区榜\n\n- [x] 美国公告牌榜\n\n- [x] 英国UK榜\n\n- [x] YouTube榜\n\n- [ ] 抖音排行榜\n\n- [ ] 网络歌曲榜\n\n- [ ] 电音榜\n\n- [ ] 说唱榜\n\n- [ ] ACG新歌榜\n\n- [ ] 达人音乐榜\n\n- [ ] K歌金曲榜\n\n- [ ] JOOX本地热播榜\n\n- [ ] 台湾KKBOX榜\n\n## 榜单适配进度\n\n由于每个榜单的爬取规则不同，请求参数不同，所以需要人工适配每一个榜单，工作量不小\n\n学业繁忙，无法全部适配，望谅解\n\n## 参与适配榜单\n\n您不需要会编程即可参与适配\n\n如果想要参与适配，您需要具备以下能力：\n\n- 会进行网络抓包\n- 能够分析抓包内容\n\n仅需要这两样能力，您便可以贡献适配榜单\n\n目前，我可以为您提供以下信息以减轻贡献适配榜单的工作量：\n\n- 目标网页 [https://y.qq.com/n/yqq/toplist/4.html](https://y.qq.com/n/yqq/toplist/4.html)\n- 包含榜单音乐id的文件为 musicu.fcg文件\n- 上述大约在网页打开后3000-5000ms内出现\n\n贡献者需要向我提供以下内容\n\n- 请求url及参数\n- 返回内容分析方法\n\n贡献方式\n\n1. 通过邮箱发给我，可以在[我的网站](https://lakphy.github.io)找到我的邮箱\n\n2. 在仓库下发布 issue\n\n3. 通过各种可以联系到我本人的方式\n\n","tags":["Python"]},{"title":"生活可以被疫情影响，但我们绝不能被疫情打败。","url":"/blog/2020/03/20/生活可以被疫情影响，但我们绝不能被疫情打败。/","content":"> 生活可以被疫情影响，但我们绝不能被疫情打败。      -----雷军__2020年小米10发布会\n\n随着国内疫情的逐渐好转，也快到该上学的时间了，此时正是我需要倍加努力的时间。\n\n由于疫情影响，高三的开学延期了一个多月，虽有网络教学，但效果始终不理想，刚开始第一周可能效果还行，但第二周效果下降就很严重了，有个经常给电脑刷机的同学说第二周有三个同学在问他怎么给电脑刷机。。。。这效果我觉得不必说了吧。\n\n距离高考还有78天，此时我对于未来充满恐慌，本应该刻苦奋斗都一个月因为疫情耽误白白荒废，我该如何应对接下来的学习。\n\n距离全市第一次统一模拟考试还有20天左右的时间，这是第一次高考前大型考试，但由于疫情推迟，这可能也是最后一次。这二十天里我应该加倍努力学习，尽管暂时还不能开学。耽误了这么长时间，该奋斗一波了，欠的总是要还的，只有更大倍数的努力，才能填平之前耽搁下的坑。\n\n疫情是病魔，但不是心魔，它是用来磨砺内心的，不是用来摧毁内心的\n\n正如文题，雷军所说\n> 生活可以被疫情影响，但我们绝不能被疫情打败。\n\n![小米10发布会](1.jpg)\n\n我不会被疫情打败，我愿在疫情环境下磨砺自己！\n\n希望我下次再看这篇博文时我的成绩能有不小的提升！\n\n也希望其他小伙伴们不管你是否高考，都不要被疫情打败，希望疫情过后能看到更强大的你我！\n\n\n","tags":["精神食粮"]},{"title":"手机市场究竟会不会消失","url":"/blog/2020/03/04/手机市场究竟会不会消失/","content":"近期很火的这个新闻，华为余承东在2015年3月4日称手机市场将会在三到五年内消失，而今天正是余承东预言中的最后限期，手机公司不仅没有消失，还越做越好，以小米一加欧珀为首的国产手机更是扬名中外，越做越好\n今天我们就来讨论一下手机市场究竟会不会消失\n[余承东原新闻链接](https://tech.qq.com/a/20150304/049924.htm)\n# 手机市场会不会消失\n不会，不仅不会消失，甚至有可能长期存在\n手机的发明让人们的生活更加便捷，经过数十年的发展，手机已经不只是一个通讯工具了，而是发展到稳定形态的智能工具，已经完全融入现代人们的生活当中，这种稳定将会持续相当一段时间\n# 什么样的产品最终会代替手机\n现阶段无法预测什么样设备可以替代手机\n有人可能会说可穿戴设备，但是，可穿戴设备为考虑便携性等等方面，使用低功耗芯片及小电池，这样的设计注定了可穿戴设备只能作为分终端使用，不能作为主终端\n作为便携设备，云终端方案不可行，一方面云终端节约不了多大体积，另一方面云终端限制很多，没网就凉了。\n有人可能会说使用华为的分布式方案，但分布式方案对分终端的性能需求比主终端方案更高，更耗电，想象一下，你不带手机，但是你的手表，耳机，眼镜，都要和你的手机一样重，保守点说，手机的一半重量，一半的体积，你能接受吗，光你的鼻托就受不了，当然谷歌glass通过夹紧头解决压力问题，但还是不够完美。\n就目前看，最完美解决方案还是手机作为主终端，可穿戴设备分布在身体各处，他们只需要一个小型芯片和小型电池就可以运行，数据全部交给手机处理，由此可看出，手机现阶段无法被替代\n# 替代手机的设备应当有什么样的功能\n最低需求接受比手机功能多，使用场景更多\n这也是可穿戴设备弊端，可穿戴设备功能少，使用场景少，手机使用场景非常多，毕竟一个屏幕，没有形态限制，配合生态变态的Linux，你想干什么都可以，甚至当电脑用都没有任何问题","tags":["数码"]},{"title":"MarkDown语法使用","url":"/blog/2020/03/04/MarkDown语法使用/","content":"\\`行内代码块\\`\n`这是行内代码块`\n代码块\n\\`\\`\\`\n这里是代码块\n\\`\\`\\`\n```\n这里是代码块\n```\n\\*斜体\\*\n*这是斜体字*\n\\*\\*粗体字\\*\\*\n**这是粗体**\n标题\n\\#一级标题\n\\#\\#二级标题\n\\#\\#\\#三级标题\n\\#\\#\\#\\#四级标题\n\\#\\#\\#\\#\\#五级标题\n\\#\\#\\#\\#\\#\\#六级标题\n分隔线\n\\*\\*\\* 或者 \\-\\-\\-\n***\n---\n\\~\\~删除线\\~\\~\n~~这个文本被划去~~\n链接\n```\n[链接文字](链接地址 \"链接标题\")\n```\n插入图片\n```\n![图片说明](图片链接 \"图片标题\")\n```\n插入视频\n```html\n<script src=\"/js/youtube-autoresizer.js\"></script>\n<iframe width=\"640\" height=\"360\" src=\"https://www.youtube.com/embed/HfElOZSEqn4\" frameborder=\"0\" allowfullscreen></iframe>\n```\n插入音频，使用插件hexo-tag-aplayer，语法如下：\n```\n{% aplayer title author url [picture_url, narrow, autoplay, width:xx%, lrc:xxx] %}\n```\n转义符\n\\\\\n引用\n\\>\n>引用了一句话\n\n使用 \\[\\^\\1\\] \\[\\^\\1\\]\\: 的脚注对来表示\n```\nHere is a footnote reference,[^1] and another.[^longnote]\n\n[^1]: Here is the footnote.\n\n[^longnote]: Here's one with multiple blocks.\n    Subsequent paragraphs are indented to show that they\n    belong to the previous footnote.\n```\nHere is a footnote reference,[^1] and another.[^longnote]\n\n[^1]: Here is the footnote.\n\n[^longnote]: Here's one with multiple blocks.\n    Subsequent paragraphs are indented to show that they\n    belong to the previous footnote.\n无序列表\n```\n+ 无序列表项 一\n\t- 子无序列表 一\n\t- 子无序列表 二\n\t\t* 子无序列表 三\n+ 无序列表项 二\n+ 无序列表项 三\n```\n+ 无序列表项 一\n\t- 子无序列表 一\n\t- 子无序列表 二\n\t\t* 子无序列表 三\n+ 无序列表项 二\n+ 无序列表项 三\n\n有序列表\n```\n1. 有序列表项 一\n\t1. 子有序列表项 一\n\t2. 子有序列表项 二\n2. 有序列表项 二\n3. 有序列表项 三\n```\n1. 有序列表项 一\n\t1. 子有序列表项 一\n\t2. 子有序列表项 二\n2. 有序列表项 二\n3. 有序列表项 三\n\n绘制表格格式如下，| 控制分列，- 控制分行，: 控制对齐方式。\n```\n| Item     | Value     | Qty   |\n| :------- | --------: | :---: |\n| Computer | 1600 USD  | 5     |\n| Phone    | 12 USD    | 12    |\n| Pipe     | 1 USD     | 234   |\n```\n| Item     | Value     | Qty   |\n| :------- | --------: | :---: |\n| Computer | 1600 USD  | 5     |\n| Phone    | 12 USD    | 12    |\n| Pipe     | 1 USD     | 234   |\n\n关于LaTeX公式，这个比较复杂，不解释，搜索引擎解决","tags":["踩坑记录"]},{"title":"用Arduino开发板演奏音乐","url":"/blog/2020/02/21/用Arduino开发板演奏音乐/","content":"\n本篇介绍如何使用Arduino开发板配合无源蜂鸣器演奏音乐\n\n制作前警告：请先通过搜索补充基础的音乐简谱知识，这些知识并不难，我也是现学的；另外需要很好的耐心，因为要输很多音符和拍子，最后调试拍速也很麻烦\n\n# 材料准备\n\n## Arduino UNO开发板\n\n这是Arduino最经典的开发板之一，本篇全部内容在此开发板上完成\n\n![Arduino UNO](uno.jpg)\n\n相关链接\n\n[Arduino官网](https://arduino.cc/)\n\n[Arduino UNO 开发板的官方介绍](https://store.arduino.cc/usa/arduino-uno-rev3)\n\n## Arduino IDE\n\n用于写入程序，Arduino IDE支持的平台很多，在安卓，webAPP，MacOS，Linux，Windows都有相应版本，本质是一样的，哪个平台都可以编译。\n\n![ArduinoIDE](ide.jpg)\n\n我使用的是GNU/Linux平台的ArduinoIDE\n\n## 蜂鸣器\n\n蜂鸣器是一种电子发声元器件，可以发出\"beep\"的声音。采用直流电压供电，广泛应用于计算机、打印机、复印机、报警器、电子玩具、汽车电子设备、电话机、定时器等电子产品中作发声器件。\n\n蜂鸣器分为有源蜂鸣器和无源蜂鸣器两种。\n\n有源蜂鸣器： 内部带有震荡源，只要一通电就会发出固定频率的声音。有源蜂鸣器特点是分正负极，正反电阻不同，类似二极管。\n\n![有源蜂鸣器](you.jpg)\n\n无源蜂鸣器：内部不带震荡源，需要使用2KHz到5KHz的脉冲信号驱动发声，声音频率可变。特点是不区分正负极，正反电阻相同，本质就是一个电磁铁驱动铁片发声。\n\n![无源蜂鸣器](wu.jpg)\n\n## LED灯（可选）\n\n我这里为了增强效果使用LED灯，可以不用\n\n## 电池\n\n略\n\n## 电路图\n\n![接线图](board.jpg)\n\n# 程序实现\n\n## 定义蜂鸣器发声\n\n### 预定义\n\n为方便录入蜂鸣器发声频率，我们预定义了七个音符的中音和低音频率以及零音符\n\n![简谱音符频率对照表](1.png)\n\n我要使用的音乐只有中音和低音，所以我只定义了中音和低音，代码如下：\n\n```C++\n#define Do 262    //1\n#define Re 294    //2\n#define Mi 330    //3\n#define Fa 349    //4\n#define Sol 392   //5\n#define La 440    //6\n#define Si 494    //7\n#define Do_h 523  //1\n#define Re_h 587  //2\n#define Mi_h 659  //3\n#define Fa_h 698  //4\n#define Sol_h 784 //5\n#define La_h 880  //6\n#define Si_h 988  //7\n#define No 0\n```\n\n### 录入简谱\n\n以下是我要录入的歌曲 归去来兮 的简谱\n\n![归去来兮简谱](music.jpg)\n\n这里有个好玩的事，因为录入量很大（约375个音符）所以我继之前创新了“让Python帮我写JavaScript”以及“让JavaScript帮我写Web”的写法，我又创新了“让Python帮我写C”（Arduino基本语法与C类似，从C转到Arduino没什么压力），下面这个是代替我录入音符的Python\n\n```Python\n#!/usr/bin/python3\n# -*- coding: utf-8 -*-\ntotx=\"\"\ntoty=\"\"\ntotz=\"\"\nwhile True:\n\tb=''\n\tx=input(\"x=\")\n\tif str(x)==\"exit\":\n\t\tprint('yes')\n\t\tdoc = open('out.txt','w')\n\t\tdoc.write(totx)\n\t\tdoc.close()\n\tif str(x)==\"1\":\n\t\tb=\"Do_h\"\n\telif str(x)==\"2\":\n\t\tb=\"Re_h\"\n\telif str(x)==\"3\":\n\t\tb=\"Mi_h\"\n\telif str(x)==\"4\":\n\t\tb=\"Fa_h\"\n\telif str(x)==\"5\":\n\t\tb=\"Sol_h\"\n\telif str(x)==\"6\":\n\t\tb=\"La_h\"\n\telif str(x)==\"7\":\n\t\tb=\"Si_h\"\n\telif str(x)==\"10\":\n\t\tb=\"Do\"\n\telif str(x)==\"20\":\n\t\tb=\"Re\"\n\telif str(x)==\"30\":\n\t\tb=\"Mi\"\n\telif str(x)==\"40\":\n\t\tb=\"Fa\"\n\telif str(x)==\"50\":\n\t\tb=\"Sol\"\n\telif str(x)==\"60\":\n\t\tb=\"La\"\n\telif str(x)==\"70\":\n\t\tb=\"Si\"\n\telif str(x)==\"0\":\n\t\tb=\"No\"\n\ta=b\n\ttotx+=a\n\ttotx+=\",\"\ndoc = open('out.txt','w')\ndoc.write(totx)\ndoc.write(\"\\n\\n\\n\")\ndoc.write(toty)\ndoc.write(\"\\n\\n\\n\")\ndoc.write(totz)\ndoc.write(\"\\n\\n\\n\")\n\n#x=input(\"\")\n```\n\n这个Python写的不好，连跳出都没有，仅仅临时使用，想关就强关就行了\n\n另外再科普一下音符高低音看法\n\n![高低音标志](2.jpg)\n\n以及零音符意义\n\n![零音符](3.jpg)\n\n录入以后的音符是这样子：\n\n```C++\nint16_t scale[] = {\n  La   , Do_h , Mi_h , Sol  , Sol  , Sol  , Re_h , Mi_h , Do_h , La   ,\n  La   , La   , Mi_h , Mi_h , Do_h , Re_h , Do_h , Re_h , Do_h , Mi_h , Mi_h , Do_h ,\n  Re_h , Do_h , Re_h , Do_h , Re_h , Do_h , Re_h , Do_h , Re_h , Mi_h , Fa_h , Mi_h ,\n  La   , La   , Mi_h , Mi_h , Do_h , Re_h , Do_h , Re_h , Do_h , Mi_h , Mi_h , Do_h ,\n  Re_h , Do_h , Re_h , Do_h , Re_h , Do_h , Re_h , Do_h , Re_h , Do_h , La   , La   ,\n  La_h , La_h , La_h , Mi_h , Do_h , Re_h , Do_h , Re_h , Do_h , Mi_h , Mi_h , Do_h ,\n  Re_h , Do_h , Re_h , Do_h , Re_h , Re_h , Do_h , Re_h , Re_h , Mi_h , Sol_h, Mi_h ,\n  La   , La   , Mi_h , Mi_h , Do_h , Re_h , Do_h , Re_h , Do_h , Mi_h , Mi_h , Do_h ,\n  Re_h , Do_h , Re_h , Re_h , Do_h , Re_h , Re_h , Re_h , Do_h , Re_h , La   ,\n  La   , La_h , Mi_h , Re_h , Mi_h , Re_h , Do_h , Re_h , Do_h , Re_h , Sol_h, Mi_h ,\n  La   , Mi_h , Re_h , Do_h , Mi_h , Re_h , Do_h , Re_h , Mi_h , Re_h , Do_h , La   ,\n  La   , La_h , Mi_h , Re_h , Mi_h , Re_h , Do_h , Re_h , Do_h , Re_h , Sol_h, Mi_h ,\n  La   , Mi_h , Re_h , Do_h , Mi_h , Re_h , Do_h , Re_h , Mi_h , Re_h , Do_h , La   ,\n  No   , La   , Do_h , Re_h , Mi_h , Re_h , Mi_h , Mi_h , No   , La   , Do_h ,\n  Re_h , Mi_h , Re_h , Do_h , Do_h , No   , La   , Do_h , Re_h , Mi_h , Re_h , Mi_h , Mi_h , No   , La   , Do_h , Re_h , Mi_h , Re_h , Do_h , Do_h ,\n  La   , La   , Mi_h , Mi_h , Do_h , Re_h , Do_h , Re_h , Do_h , Mi_h , Mi_h , Do_h ,\n  Re_h , Do_h , Re_h , Do_h , Re_h , Do_h , Re_h , Do_h , Re_h , Mi_h , Fa_h , Mi_h ,\n  La   , La   , Mi_h , Mi_h , Do_h , Re_h , Do_h , Re_h , Do_h , Mi_h , Mi_h , Do_h ,\n  Re_h , Do_h , Re_h , Do_h , Re_h , Do_h , Re_h , Do_h , Re_h , Do_h , Re_h , La   ,\n  La_h , La_h , La_h , Mi_h , Do_h , Re_h , Do_h , Re_h , Do_h , Mi_h , Mi_h , Do_h ,\n  Re_h , Do_h , Re_h , Do_h , Re_h , Do_h , Re_h , Do_h , Re_h , Mi_h , Fa_h , Mi_h ,\n  La   , La   , Mi_h , Mi_h , Do_h , Re_h , Do_h , Re_h , Do_h , Mi_h , Mi_h , Do_h ,\n  Re_h , Do_h , Re_h , Re_h , Do_h , Re_h , Do_h , Re_h , Do_h , Re_h , La   ,\n  La   , La_h , Mi_h , Re_h , Mi_h , Re_h , Do_h , Re_h , Do_h , Re_h , Sol_h, Mi_h ,\n  La   , Mi_h , Re_h , Do_h , Mi_h , Re_h , Do_h , Re_h , Mi_h , Re_h , Do_h , La   ,\n  La   , La_h , Mi_h , Re_h , Mi_h , Re_h , Do_h , Re_h , Do_h , Re_h , Sol_h, Mi_h ,\n  La   , Mi_h , Re_h , Do_h , Mi_h , Re_h , Do_h , Re_h , Mi_h , Re_h , Do_h , La   ,\n  La   , La_h , Mi_h , Re_h , Mi_h , Re_h , Do_h , Re_h , Do_h , Re_h , Sol_h, Mi_h ,\n  La   , Mi_h , Re_h , Do_h , Mi_h , Re_h , Do_h , Re_h , Mi_h , Re_h , Do_h , La   ,\n  La   , La_h , Mi_h , Re_h , Mi_h , Re_h , Do_h , Re_h , Do_h , Re_h , Sol_h, Mi_h ,\n  La   , Mi_h , Re_h , Do_h , Mi_h , Re_h , Do_h , Re_h , Mi_h , Re_h , Do_h , La\n};\n```\n\n另外解释一下为什么用\"int16_t\"，因为音符太多，会超内存，如果用默认32位int定义整形会浪费内存（ArduinoUNO的存储为4kb）\n\n### 定义节拍\n\n音乐中每个音时长不同，这个也要定义\n\n简谱中节拍定义：\n\n![节拍](4.jpg)\n\n这个节拍我们后面会乘一个固定系数即为延迟，这取决于音乐本身速度，应该是和简谱左上角的几个字有关，自己听原版调也可以\n\n定义节拍我也做了辅助录入的Python脚本\n\n```Python\n#!/usr/bin/python3\n# -*- coding: utf-8 -*-\ntotx=\"\"\ntoty=\"\"\ntotz=\"\"\nwhile True:\n\tb=''\n\tx=input(\"x=\")\n\tif str(x)==\"exit\":\n\t\tprint('yes')\n\t\tdoc = open('out.txt','w')\n\t\tdoc.write(totx)\n\t\tdoc.close()\n\tif str(x)==\"1\":\n\t\tb=\"0.25\"\n\telif str(x)==\"2\":\n\t\tb=\"0.5\"\n\telif str(x)==\"3\":\n\t\tb=\"1\"\n\telif str(x)==\"4\":\n\t\tb=\"2\"\n\ta=b\n\ttotx+=a\n\ttotx+=\",\"\n```\n\n录入后效果如下:\n\n```C++\nint8_t durt[] =\n{\n  2, 2, 2, 2, 8, 2, 2, 2, 2, 8,\n  2, 2, 2, 1, 1, 1, 1, 1, 1, 2, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 4,\n  2, 2, 2, 1, 1, 1, 1, 1, 1, 2, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 4,\n  2, 2, 1, 2, 1, 1, 1, 1, 1, 2, 1, 1,\n  1, 1, 1, 1, 2, 1, 1, 2, 1, 1, 2, 2,\n  2, 2, 2, 1, 1, 1, 1, 1, 1, 2, 1, 1,\n  1, 1, 2, 1, 1, 2, 1, 2, 1, 2, 2,\n  4, 4, 2, 2, 4, 2, 2, 2, 2, 2, 2, 4,\n  4, 4, 2, 2, 4, 2, 2, 2, 2, 2, 2, 4,\n  4, 4, 2, 2, 4, 2, 2, 2, 2, 2, 2, 4,\n  4, 4, 2, 2, 4, 2, 2, 2, 2, 2, 2, 4,\n  4, 4, 8, 2, 2, 2, 2, 8, 4, 4, 8,\n  2, 2, 2, 2, 8, 4, 4, 8, 2, 2, 2, 2, 8, 4, 4, 8, 2, 2, 2, 2, 8,\n  2, 2, 2, 1, 1, 1, 1, 1, 1, 2, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 4,\n  2, 2, 2, 1, 1, 1, 1, 1, 1, 2, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 4,\n  2, 2, 1, 2, 1, 1, 1, 1, 1, 2, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 4,\n  2, 2, 2, 1, 1, 1, 1, 1, 1, 2, 1, 1,\n  1, 1, 2, 1, 1, 1, 1, 1, 1, 2, 4,\n  4, 4, 2, 2, 4, 2, 2, 2, 2, 2, 2, 4,\n  4, 4, 2, 2, 4, 2, 2, 2, 2, 2, 2, 4,\n  4, 4, 2, 2, 4, 2, 2, 2, 2, 2, 2, 4,\n  4, 4, 2, 2, 4, 2, 2, 2, 2, 2, 2, 4,\n  4, 4, 2, 2, 4, 2, 2, 2, 2, 2, 2, 4,\n  4, 4, 2, 2, 4, 2, 2, 2, 2, 2, 2, 4,\n  4, 4, 2, 2, 4, 2, 2, 2, 2, 2, 2, 4,\n  4, 4, 2, 2, 4, 2, 2, 2, 2, 2, 2, 1\n};\n```\n\n这里我们用了int8_t，定义成8位整数，这样能节约一半以上内存（我一开始用浮点数定义，内存直接爆了）\n\n## 全局变量\n\n上面的蜂鸣器发声定义使用的是全局变量，下面再定义其他必须全局变量\n\n定义发声针脚为A0\n\n```C++\nint tonepin = A0;\n```\n\n定义长度，后面要用\n\n```C++\nint length;\n```\n\n## 初始化程序\n\n此程序用于初始化开发板\n\n初始化了发声针脚以及亮灯针脚并将所有针脚设定为零电势以保障安全\n\n```C++\nvoid setup()\n{\n  pinMode(tonepin, OUTPUT);//设置发声脚\n  pinMode(A2, OUTPUT);//设置LED输出脚\n  digitalWrite(A2, LOW);//设置输出脚电势\n  pinMode(A3, OUTPUT);//同上\n  digitalWrite(A3, LOW);\n  pinMode(A4, OUTPUT);\n  digitalWrite(A4, LOW);\n  pinMode(A5, OUTPUT);\n  digitalWrite(A5, LOW);\n  for (int i = 1; i <= 13; i++) {\n    pinMode(i, OUTPUT);\n    digitalWrite(i, LOW);\n  }\n  length = sizeof(scale) / sizeof(scale[0]);//定义音乐长度\n}\n```\n\n## 循环播放音乐主程序\n\n先看API：\n\nnoTone(tonepin);//停止发声\n\ntone(tonepin, scale[x]);//发声，参数一发声脚，参数二频率\n\ndigitalWrite(i, HIGH);//用于修改LED输出脚电势，参数一输出脚，参数二电势（LOW为低电势，一般理解为零电势，HIGH为高电势，具体电势不明）\n\ndelay(a);//延时，参数为毫秒数\n\n代码如下：\n\n```C++\nvoid loop()\n{\n  for (int x = 0; x < length; x++)\n  {\n    if (scale[x] == 0) {\n      noTone(tonepin);\n    }\n    else{\n      tone(tonepin, scale[x]);\n    }\n    //digitalWrite(ledpin,HIGH);\n    for (int i = 1; i <= 13; i++) {\n      if (i % 4 == 1) {\n        digitalWrite(i, HIGH);\n      }\n    }\n    digitalWrite(A3, LOW);\n    digitalWrite(A5, HIGH);\n    for (int i = 1; i <= 13; i++) {\n      if (i % 4 == 3) {\n        digitalWrite(i, LOW);\n      }\n    }\n    delay(750 * durt[x] / 4);//节拍延时\n    //digitalWrite(ledpin,LOW);\n    for (int i = 1; i <= 13; i++) {\n      if (i % 4 == 1) {\n        digitalWrite(i, LOW);\n      }\n    }\n    digitalWrite(A5, LOW);\n    digitalWrite(A3, HIGH);\n    for (int i = 1; i <= 13; i++) {\n      if (i % 4 == 3) {\n        digitalWrite(i, HIGH);\n      }\n    }\n    delay(150 * durt[x] / 4);//节拍延时\n    noTone(tonepin);\n  }\n  delay(3000);\n}\n```\n\n# 开始使用\n\n至此，你的开发板已可以唱歌，全部代码如下（伸手党请看这里）\n\n```C++\n#define Do 262    //1\n#define Re 294    //2\n#define Mi 330    //3\n#define Fa 349    //4\n#define Sol 392   //5\n#define La 440    //6\n#define Si 494    //7\n#define Do_h 523  //1\n#define Re_h 587  //2\n#define Mi_h 659  //3\n#define Fa_h 698  //4\n#define Sol_h 784 //5\n#define La_h 880  //6\n#define Si_h 988  //7\n#define No 0\nint length;\nint16_t scale[] = {\n  La   , Do_h , Mi_h , Sol  , Sol  , Sol  , Re_h , Mi_h , Do_h , La   ,\n  La   , Do_h , Mi_h , Sol  , Sol  , Sol  , Re_h , Mi_h , Do_h , La   ,\n  La   , La   , Mi_h , Mi_h , Do_h , Re_h , Do_h , Re_h , Do_h , Mi_h , Mi_h , Do_h ,\n  Re_h , Do_h , Re_h , Do_h , Re_h , Do_h , Re_h , Do_h , Re_h , Mi_h , Fa_h , Mi_h ,\n  La   , La   , Mi_h , Mi_h , Do_h , Re_h , Do_h , Re_h , Do_h , Mi_h , Mi_h , Do_h ,\n  Re_h , Do_h , Re_h , Do_h , Re_h , Do_h , Re_h , Do_h , Re_h , Do_h , La   , La   ,\n  La_h , La_h , La_h , Mi_h , Do_h , Re_h , Do_h , Re_h , Do_h , Mi_h , Mi_h , Do_h ,\n  Re_h , Do_h , Re_h , Do_h , Re_h , Re_h , Do_h , Re_h , Re_h , Mi_h , Sol_h, Mi_h ,\n  La   , La   , Mi_h , Mi_h , Do_h , Re_h , Do_h , Re_h , Do_h , Mi_h , Mi_h , Do_h ,\n  Re_h , Do_h , Re_h , Re_h , Do_h , Re_h , Re_h , Re_h , Do_h , Re_h , La   ,\n  La   , La_h , Mi_h , Re_h , Mi_h , Re_h , Do_h , Re_h , Do_h , Re_h , Sol_h, Mi_h ,\n  La   , Mi_h , Re_h , Do_h , Mi_h , Re_h , Do_h , Re_h , Mi_h , Re_h , Do_h , La   ,\n  La   , La_h , Mi_h , Re_h , Mi_h , Re_h , Do_h , Re_h , Do_h , Re_h , Sol_h, Mi_h ,\n  La   , Mi_h , Re_h , Do_h , Mi_h , Re_h , Do_h , Re_h , Mi_h , Re_h , Do_h , La   ,\n  No   , La   , Do_h , Re_h , Mi_h , Re_h , Mi_h , Mi_h , No   , La   , Do_h ,\n  Re_h , Mi_h , Re_h , Do_h , Do_h , No   , La   , Do_h , Re_h , Mi_h , Re_h , Mi_h , Mi_h , No   , La   , Do_h , Re_h , Mi_h , Re_h , Do_h , Do_h ,\n  La   , La   , Mi_h , Mi_h , Do_h , Re_h , Do_h , Re_h , Do_h , Mi_h , Mi_h , Do_h ,\n  Re_h , Do_h , Re_h , Do_h , Re_h , Do_h , Re_h , Do_h , Re_h , Mi_h , Fa_h , Mi_h ,\n  La   , La   , Mi_h , Mi_h , Do_h , Re_h , Do_h , Re_h , Do_h , Mi_h , Mi_h , Do_h ,\n  Re_h , Do_h , Re_h , Do_h , Re_h , Do_h , Re_h , Do_h , Re_h , Do_h , Re_h , La   ,\n  La_h , La_h , La_h , Mi_h , Do_h , Re_h , Do_h , Re_h , Do_h , Mi_h , Mi_h , Do_h ,\n  Re_h , Do_h , Re_h , Do_h , Re_h , Do_h , Re_h , Do_h , Re_h , Mi_h , Fa_h , Mi_h ,\n  La   , La   , Mi_h , Mi_h , Do_h , Re_h , Do_h , Re_h , Do_h , Mi_h , Mi_h , Do_h ,\n  Re_h , Do_h , Re_h , Re_h , Do_h , Re_h , Do_h , Re_h , Do_h , Re_h , La   ,\n  La   , La_h , Mi_h , Re_h , Mi_h , Re_h , Do_h , Re_h , Do_h , Re_h , Sol_h, Mi_h ,\n  La   , Mi_h , Re_h , Do_h , Mi_h , Re_h , Do_h , Re_h , Mi_h , Re_h , Do_h , La   ,\n  La   , La_h , Mi_h , Re_h , Mi_h , Re_h , Do_h , Re_h , Do_h , Re_h , Sol_h, Mi_h ,\n  La   , Mi_h , Re_h , Do_h , Mi_h , Re_h , Do_h , Re_h , Mi_h , Re_h , Do_h , La   ,\n  La   , Do_h , Mi_h , Sol  , Sol  , Sol  , Re_h , Mi_h , Do_h , La   ,\n  La   , Do_h , Mi_h , Sol  , Sol  , Sol  , Re_h , Mi_h , Do_h , La   ,\n  La   , La_h , Mi_h , Re_h , Mi_h , Re_h , Do_h , Re_h , Do_h , Re_h , Sol_h, Mi_h ,\n  La   , Mi_h , Re_h , Do_h , Mi_h , Re_h , Do_h , Re_h , Mi_h , Re_h , Do_h , La   ,\n  La   , La_h , Mi_h , Re_h , Mi_h , Re_h , Do_h , Re_h , Do_h , Re_h , Sol_h, Mi_h ,\n  La   , Mi_h , Re_h , Do_h , Mi_h , Re_h , Do_h , Re_h , Mi_h , Re_h , Do_h , La   ,\n  La   , Do_h , Mi_h , Sol  , Sol  , Sol  , Re_h , Mi_h , Do_h , La   ,\n  La   , Do_h , Mi_h , Sol  , Sol  , Sol  , Re_h , Mi_h , Do_h , La\n};\nint8_t durt[] =\n{\n  2, 2, 2, 2, 8, 2, 2, 2, 2, 8,\n  2, 2, 2, 2, 8, 2, 2, 2, 2, 8,\n  2, 2, 2, 1, 1, 1, 1, 1, 1, 2, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 4,\n  2, 2, 2, 1, 1, 1, 1, 1, 1, 2, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 4,\n  2, 2, 1, 2, 1, 1, 1, 1, 1, 2, 1, 1,\n  1, 1, 1, 1, 2, 1, 1, 2, 1, 1, 2, 2,\n  2, 2, 2, 1, 1, 1, 1, 1, 1, 2, 1, 1,\n  1, 1, 2, 1, 1, 2, 1, 2, 1, 2, 2,\n  4, 4, 2, 2, 4, 2, 2, 2, 2, 2, 2, 4,\n  4, 4, 2, 2, 4, 2, 2, 2, 2, 2, 2, 4,\n  4, 4, 2, 2, 4, 2, 2, 2, 2, 2, 2, 4,\n  4, 4, 2, 2, 4, 2, 2, 2, 2, 2, 2, 4,\n  4, 4, 8, 2, 2, 2, 2, 8, 4, 4, 8,\n  2, 2, 2, 2, 8, 4, 4, 8, 2, 2, 2, 2, 8, 4, 4, 8, 2, 2, 2, 2, 8,\n  2, 2, 2, 1, 1, 1, 1, 1, 1, 2, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 4,\n  2, 2, 2, 1, 1, 1, 1, 1, 1, 2, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 4,\n  2, 2, 1, 2, 1, 1, 1, 1, 1, 2, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 4,\n  2, 2, 2, 1, 1, 1, 1, 1, 1, 2, 1, 1,\n  1, 1, 2, 1, 1, 1, 1, 1, 1, 2, 4,\n  4, 4, 2, 2, 4, 2, 2, 2, 2, 2, 2, 4,\n  4, 4, 2, 2, 4, 2, 2, 2, 2, 2, 2, 4,\n  4, 4, 2, 2, 4, 2, 2, 2, 2, 2, 2, 4,\n  4, 4, 2, 2, 4, 2, 2, 2, 2, 2, 2, 4,\n  2, 2, 2, 2, 8, 2, 2, 2, 2, 8,\n  2, 2, 2, 2, 8, 2, 2, 2, 2, 8,\n  4, 4, 2, 2, 4, 2, 2, 2, 2, 2, 2, 4,\n  4, 4, 2, 2, 4, 2, 2, 2, 2, 2, 2, 4,\n  4, 4, 2, 2, 4, 2, 2, 2, 2, 2, 2, 4,\n  4, 4, 2, 2, 4, 2, 2, 2, 2, 2, 2, 1,\n  2, 2, 2, 2, 8, 2, 2, 2, 2, 8,\n  2, 2, 2, 2, 8, 2, 2, 2, 2, 8\n};\nint tonepin = A0;\nvoid setup()\n{\n  pinMode(tonepin, OUTPUT);\n  pinMode(A2, OUTPUT);\n  digitalWrite(A2, LOW);\n  pinMode(A3, OUTPUT);\n  digitalWrite(A3, LOW);\n  pinMode(A4, OUTPUT);\n  digitalWrite(A4, LOW);\n  pinMode(A5, OUTPUT);\n  digitalWrite(A5, LOW);\n  for (int i = 1; i <= 13; i++) {\n    pinMode(i, OUTPUT);\n    digitalWrite(i, LOW);\n  }\n  length = sizeof(scale) / sizeof(scale[0]);\n}\nvoid loop()\n{\n  for (int x = 0; x < length; x++)\n  {\n    if (scale[x] == 0) {\n      noTone(tonepin);\n    }\n    else {\n      tone(tonepin, scale[x]);\n    }\n    //digitalWrite(ledpin,HIGH);\n    for (int i = 1; i <= 13; i++) {\n      if (i % 4 == 1) {\n        digitalWrite(i, HIGH);\n      }\n    }\n    digitalWrite(A3, LOW);\n    digitalWrite(A5, HIGH);\n    for (int i = 1; i <= 13; i++) {\n      if (i % 4 == 3) {\n        digitalWrite(i, LOW);\n      }\n    }\n    delay(660 * durt[x] / 4);\n    //digitalWrite(ledpin,LOW);\n    for (int i = 1; i <= 13; i++) {\n      if (i % 4 == 1) {\n        digitalWrite(i, LOW);\n      }\n    }\n    digitalWrite(A5, LOW);\n    digitalWrite(A3, HIGH);\n    for (int i = 1; i <= 13; i++) {\n      if (i % 4 == 3) {\n        digitalWrite(i, HIGH);\n      }\n    }\n    delay(150 * durt[x] / 4);\n    noTone(tonepin);\n  }\n  delay(3000);\n}\n```\n\n其他音乐同理，不做解释，建议自行搜索学习音乐基础知识。\n\n# 最后一步，测试\n\n这是最重要的一步，我测试了很长时间才能保证我的开发板可以和原音乐拍子对上，测试主要测两个，一是拍速，而是音符是否正确","tags":["Arduino"]},{"title":"Python实现微信接龙转换为表格","url":"/blog/2020/02/19/Python实现微信接龙转换为表格/","content":"\n近期在家中上网课，因为形式特殊，班群里经常通过接龙统计些信息，比如说错题、住址（用来寄学习资料）等等，有的统计成接龙还好说，但有的要改成表格，所以老师是接龙文字还是接龙表格呢？？？？\n\n接龙文字：微信接龙辅助，不会漏人，很不错，但改成表格麻烦\n\n接龙表格：这个直接，但经常漏人啊。。。\n\n于是开发了一个项目，名为 Solitaire，用于格式化文字接龙内容为表格\n\n基于pyforms的GUI框架\n\npyforms是基于pyqt的GUI框架，有点臃肿。。。\n\n不建议打包，我打包了一下，环境 windows2016，工具pyinstaller\n\n打包完大小160mb左右。。。。。\n\n它估计把整个pyqt都放进去了\n\n## 使用方法\n\n先安装依赖（我认为你已安装Python）\n\n``` s\npip install xlwt\npip install pyforms\n```\n\n然后下面是代码：\n\n``` Python\nimport pyforms\nfrom   pyforms.basewidget import BaseWidget\nfrom   pyforms.controls   import ControlText\nfrom   pyforms.controls   import ControlLabel\nfrom   pyforms.controls   import ControlTextArea\nfrom   pyforms.controls   import ControlButton\nimport xlwt\nclass SimpleExample1(BaseWidget):\n    def __init__(self):\n        super(SimpleExample1,self).__init__('接龙格式化工具-----Lakphy')\n        self._fullname      = ControlTextArea('接龙内容')\n        self._test          = ControlLabel('请输入接龙内容后点击格式化，即可转换为表格\\n请注意使用\\'--\\'即两个减号为每个数据分隔符，使用换行作为每个人的数据分隔符！\\nCopyRight Lakphy 2020\\n网站:lakphy.me')\n        self._button        = ControlButton('格式化')\n        self._button.value  = self.__buttonAction\n    def __buttonAction(self):\n        self._test.value = str(self._fullname.value.split('\\n'))\n        a      = self._fullname.value.split('\\n')\n        wk     = xlwt.Workbook()\n        sheet1 = wk.add_sheet(\"数据\", cell_overwrite_ok=True)\n        for i in range(0,len(a)):\n            b  = a[i].split('--')\n            for j in range(0,len(b)):\n                if j == 0:\n                    d = b[j].split('. ',2)\n                    if len(d) == 2:\n                        c = d[1]\n                    else:\n                        d = b[j].split('.',2)\n                        if len(d) == 2:\n                            c = d[1]\n                        else:\n                            c = b[j]\n                else:\n                    c = b[j]\n                sheet1.write(i+1,j+1,c)\n            sheet1.write(i+1,0,i+1)\n        wk.save('Solitaire.xls')\n        self._test.value = '接龙内容格式化成功！内容保存在Solitaire.xls，请及时备份该文件，防止下次使用该软件时覆盖内容！\\nCopyRight Lakphy 2020\\n网站:lakphy.me'\nif __name__ == \"__main__\": pyforms.start_app( SimpleExample1 )\n```\n\n附文：[pyforms文档](<https://pyforms.readthedocs.io/projects/Pyforms-GUI/en/v4/getting-started/the-basic.html>)","tags":["Python"]},{"title":"SourLib","url":"/blog/2020/02/18/SourLib/","content":"\n打开网站-->搜索资源-->获取资源\n找资源，从未像这样自然过\n\n[SourLib](https://lakphy.github.io/res) / [国内线路](https://lakphy.gitee.io/res)\n\n![](1-1Q0112004410-L.jpg)\n\n\n\n想看某个电影，或是，某部电视剧\n但始终找不到资源？\n在这里，资源触手可得\n![](th1.jpg)\n\n\n\n仅仅是资源？No\n海量在线小工具，等你来发现\n用不完的工具，让您的工作学习生活事半功倍\n![](th.jpg)\n\n\n\n基于优秀的MDUI前端技术，与这取之不尽的资源浑然天成\n只有像Material Design这样优秀的设计规范才能与这优秀的资源相匹配\n![](pic2-mob-1107.png)\n\n\n\n基于CSS3采用先进的响应式布局，不管是在手机，还是平板，还是电脑，甚至是，电视？我们都能自如地适应您的屏幕，让您享受最棒的观感和最高的效率！\n![](e3d90e31589b4c1aa7641d16ef0be890_th.jpg)\n\n\n\n我们优秀的前端工程师为您打磨了最优秀站内搜索引擎算法，使您在这浩如烟海的资源中，总能最快找到您需要的资源\n\n[SourLib](https://lakphy.github.io/res) / [国内线路](https://lakphy.gitee.io/res)\n\n\n\n我们仍需努力，您如何有任何想要加入的资源，请联系我们\n\n","tags":["资源库"]},{"title":"deepin长期使用评测","url":"/blog/2020/02/15/deepin长期使用评测/","content":"\n由于一些不可抗拒的原因（主板莫名不兼容win）不得不选择Linux，试过多种Linux，deepin(深度操作系统)可以说是众多linux最省心好用的了。\n\n[深度操作系统官网](https://deepin.org)\n\n[深度官网](https://deepin.com/)\n\n# 如何发现这么好的系统的\n\n### 首先支持国产\n\n这个当然的，国产的好东西必须大力支持！\n\n### 国际排名高\n\n这个不多说，大众的眼睛是雪亮的，看下排名就知道啦：\n\n[排名链接](https://distrowatch.com/dwres.php?resource=popularity)\n\n![](1.png)\n\n可以看到的deepin基本稳定在第十名，注意现在时间2020年02月15日。\n\n最近疫情原因很长时间没有维护了，排名有所下降属于正常现象。\n\n记得最高排第六。\n\n### 软件生态\n\n其实我是冲软件生态来的\n\n软件生态是一个操作系统的灵魂，没有软件生态，它就不配叫操作系统，那叫啥？可能叫嵌入式系统？功能机？（Lumia警告）\n\nMicrosoft，Google，Apple都为他们操作系统生态投入了大量资金和人员，包括学生组织开发活动，软件竞赛之类的活动，或是直接给钱，足以突显软件生态的重要性。\n\n众所周知，Windows系统的整体操作逻辑已经十几年没变了，而且易用性越来越差，在众多现代操作系统中处于劣势，但为什么Windows用户永远不会降低呢，这也是软件生态的效果，Windows下的软件生态非常庞大，难以超越，这也表现了当初微软在中国地区容忍盗版泛滥现象的战略意义。\n\n好了好了，有点偏题了。\n\n下面说deepin的软件生态：\n\n1. Deepin基于Debian GNU/Linux，支持Linux软件，Debian特有的deb软件，以及Debian著名的apt包管理系统\n2. 预装wine，通过底层代码适配大量Windows软件\n3. 深度团队对于不支持wine的Windows软件进行专门适配，这个是其他发行版装了wine也比不上了的。像Windows QQ就是专门适配的，比QQ官方发布的Linux版好用\n4. 预装Chrome，支持webAPP，ChromeOS软件，安卓软件\n\n可见这软件生态真的是太强了\n\n这是GNU/Linux里生态强的，据说还有个国产的ChromeOS生态也贼强（国产都喜欢玩全平台适配？），没用过，叫fydeOS，可以去尝试一下。\n\n这个生态空口无凭，看下例子\n\n![](2.png)\n\n上面这个是应用商店，很多是深度团队自己适配来的，很良心了。\n\n![](3.png)\n\n上面这个是QQ官方的Linux版，可以看出来界面相当远古了，而且看那大小也不像好东西\n\n![](4.png)\n\n这个是wine版QQ，深度团队专门适配过的，版本也比较新，但最近好像是疫情原因还没给适配下一版本。\n\n![](5.png)\n\n上面这是应用商店里编程开发专区，可以看到这里特殊适配的就少了，毕竟开发用的软件还是给做Linux版的\n\n这里说个有意思的，深度团队还把著名游戏平台steam整来了，如下图：\n\n![](6.png)\n\n这就很厉害了，据说还能玩GTA呢\n\n下面这个是下载排行榜：（偷偷说个事：Linux版百度云不限速！）\n\n![](7.png)\n\n# 使用体验\n\n整体使用体验不错，高斯模糊运用得当\n\n### 桌面\n\n##### 桌面总览![](8.png)\n\n请无视我桌面的文件谢谢（\n\n##### dock栏\n\ndock可以设置成MacOS样式或Windows样式，非常友好\n\n![](9.png)\n\n上面这是仿win，即高效样式\n\n![](10.png)\n\n上面这个是仿MacOS样式，即潮流样式\n\n我使用的是高效样式，之后将使用高效样式演示，潮流样式类似\n\n##### 硬盘管理器\n\n![11](11.png)\n\n##### WiFi\n\n![](12.png)\n\n##### 应用列表\n\n![](13.png)\n\n这个也有两种风格，这个是仿win的，下面这个是仿MacOS的\n\n![](14.png)\n\n##### 工作区总览\n\n![](15.png)\n\n### 设置界面\n\n这里是通知界面，点右上角切换设置\n\n![](16.png)\n\n设置总览：\n\n![17](17.png)\n\n下面把整个设置截屏看看\n\n![18](18.png)\n\n\n\n![19](19.png)\n\n![20](20.png)\n\n![21](21.png)\n\n![22](22.png)\n\n![23](23.png)\n\n值得一提的是，deepin自带一个开机引导选项，非常方便\n\n![25](25.png)\n\n### 终端\n\n这终端和普通GNU/Linux终端一样，没有区别\n\n![26](26.png)\n\n### 文件管理器\n\n![27](27.png)\n\n### Chrome\n\n![28](28.png)\n\n### 电源选项\n\n![29](29.png)\n\n### 资源管理器\n\n![30](30.png)\n\n# 其他软件\n\n这里推荐几个有用的软件\n\n### 连接手机\n\n我用kdeconnect连接手机，堪比airdrop，十分好用\n\n![32](32.png)\n\n![31](31.png)\n\n### 那些你懂的飞机\n\n这个我用clash，github上有，配置有点复杂，但好用\n\n### 打代码\n\n##### VSCode\n\n![33](33.png)\n\n##### sublime text\n\n![34](34.png)\n\n# 结尾\n\n以上是我简单对deepin的评测，十分好用，目前我已使用一年多了，没什么大问题（除了上次我不小心输错命令把软件全删了），希望这个国产操作系统可以越做越好。\n","tags":["评测"]},{"title":"linux如何快速备份","url":"/blog/2020/02/13/linux如何快速备份/","content":"\n我现在使用的是deepin linux，自带备份功能，但总感觉这个备份有点。。。。\n\n> Talk is cheap,show me the screenshot。\n\n直接看图吧，备注现在时间2020-02-13（\n\n![看这时间多悠久](2.png)\n\n好像从第一次注册完账号开启自动备份后就没开过。。。\n\n我这还算好的，最起码有个界面，那些用其他发行版的大牛们怎么办啊，全盘备份？没这必要吧，只要备份重要配置文件就够了，再说全盘备份要是碰上Linus那种只用固态硬盘的硬盘就遭殃了。\n\n突然想起来Linux有批处理功能，于是打开vim和Google，开工！\n\n# 编写程序\n\n## 基本思路\n\n这里说一下备份思路\n\n1. 把重要文件（夹）复制到临时目录（因为是机械硬盘无所谓寿命）\n2. 打包成zip\n3. 移动到u盘里\n\n## 第一个功能：计时\n\n这功能真的是强迫症福音啊，废话少说放码：\n\n```\nstart=$(date \"+%s\")\t#记录开始时间\n#这里运行代码\nnow=$(date \"+%s\")\t#记录结束时间\ntime=$((now-start))\t#计算用时\necho \"time used:$time seconds\"\t#输出时间\n#echo $date\n```\n\n就这样一个计时功能出来了，果然比某某些编程语言简单，像某语言还要引用time（逃\n\n对了，科普一下，shell里输出是\n\n```\necho \"exampleString\"\t#输出文字\necho $someVar\t#输出变量\n```\n\n我测试了一下，没有代码时候输出0s，还是挺准的  :D\n\n## 建立备份临时文件夹\n\n此步在硬盘中建立临时备份文件夹，命名为当前时间\n\n建立文件夹应该都会吧，所以直接上代码\n\n```\ndate=$(date +%Y%m%d%H%m%s)\t#获取时间\nmkdir /media/lakphy/DATA/baks/$date\t#建立文件夹\n```\n\n## 建立重要文件夹名单\n\n此步建立一个数组（我习惯将列表说成数组，意义相同，以后不做解释），里面放有重要文件（夹）通报（划掉）名单\n\n```\ncopyPath=(\t#这是建立数组的代码\n\t'/home/lakphy/lakphy/golang'\n\t'/home/lakphy/lakphy/py'\n\t'/home/lakphy/lakphy/nodejs'\n\t'/home/lakphy/Downloads'\n\t'/media/lakphy/DATA/downloads'\n\t'/home/lakphy/Desktop'\n\t)\t#这是我的重要文件目录，仅示例使用\n```\n\n## 复制内容到临时备份文件夹\n\n这里利用循环遍历重要文件（夹）名单复制，这个操作我们在学习Python时候应该都学过\n\n```\nfor p in ${copyPath[@]}\t#for循环\ndo\t#循环开始符\n\techo 'copying '$p\t#输出复制信息\n\tcp -r $p /media/lakphy/DATA/baks/$date\t#Linux cp命令玄学复制，速度贼快\ndone\t#循环结束符\n```\n\n## 压缩\n\n```\npathname='/media/lakphy/DATA/baks/'$date\t#备份文件夹路径  date是我们之前定义的时间\nzipname='/media/lakphy/DATA/baks/'$date\t\t#压缩文件路径和名字\nzip -r $zipname $pathname\t\t\t\t\t#压缩命令\n```\n\n## 移动到批处理程序所在目录\n\nmv命令，这个比较简单，不解释\n\n# 完整代码\n\n来看下完整代码\n\n## codes\n\n```\n\n```\n\n\n\n## 运行\n\n保存为backup.sh\n\n如果程序在电脑上的话，直接双击或者命令:\n\n```\n./backup.sh\n```\n\n如果在外部存储器上，只能在命令行运行，命令只能是：\n\n```\nbash backup.sh\n```\n\nbash意思是解释器为bash，至于为什么是bash不是shell，这个我也不懂，我谷歌的时候写的shell啊。。。但shell真的运行不了，不信试试：\n\n```\nshell backup.sh\n```\n\n至于内部外部存储器区别，我觉得可能是外部存储器文件系统不是ext4不能加可执行权限问题\n\n我运行了一下，速度不错，比直接复制快，毕竟cp命令玄学复制，430s完成。","tags":["bash"]},{"title":"异步的哲学---旧电脑也能运用自如？","url":"/blog/2020/02/12/异步的哲学-旧电脑也能运用自如？/","content":"\n先说一句，这篇博文是瞎讨论哲学用的（\n\n# 什么是异步\n\n### 来自Wikipedia的解释（异步IO）\n\n[[原文链接](<https://zh.wikipedia.org/wiki/%E5%BC%82%E6%AD%A5IO>)]\n\n**异步IO**是计算机操作系统对[输入输出](https://zh.wikipedia.org/wiki/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA)的一种处理方式：发起IO请求的线程不等IO操作完成，就继续执行随后的代码，IO结果用其他方式通知发起IO请求的程序。与异步IO相对的是更为常见的“同步（阻塞）IO”：发起IO请求的线程不从正在调用的IO操作函数返回（即被阻塞），直至IO操作完成。\n\n#### 类Unix操作系统与POSIX[[编辑](https://zh.wikipedia.org/w/index.php?title=%E5%BC%82%E6%AD%A5IO&action=edit&section=1)]\n\nPOSIX提供下述API函数：\n\n|      | 阻塞        | 非阻塞                      |\n| ---- | ----------- | --------------------------- |\n| 同步 | write, read | write, read + poll / select |\n| 异步 | -           | aio_write, aio_read         |\n\n#### Windows操作系统的异步IO[[编辑](https://zh.wikipedia.org/w/index.php?title=%E5%BC%82%E6%AD%A5IO&action=edit&section=2)]\n\nWindows提供多种异步IO（也称[重叠IO](https://zh.wikipedia.org/wiki/%E9%87%8D%E5%8F%A0I/O)）方式：[[1\\]](https://zh.wikipedia.org/wiki/%E5%BC%82%E6%AD%A5IO#cite_note-1)\n\n##### 设备内核对象[[编辑](https://zh.wikipedia.org/w/index.php?title=%E5%BC%82%E6%AD%A5IO&action=edit&section=3)]\n\nIO设备在操作系统内核中表示为[内核对象](https://zh.wikipedia.org/wiki/%E5%86%85%E6%A0%B8%E5%AF%B9%E8%B1%A1)，因此具有可等待（waitable）内核对象状态。例如：文件[句柄](https://zh.wikipedia.org/wiki/%E5%8F%A5%E6%9F%84)，线程句柄等等。对于文件内核对象，当一个异步IO完成后，该文件句柄被置为触发态。使用这种方式获取异步IO完成的通知，缺点是如果在一个文件内核对象上同时有多个异步IO操作，只通过文件句柄的触发无法辨识哪个异步IO操作完成了。\n\n例子：\n\n```\nHANDLE hFile = CreateFileW(L\"d:\\\\a.txt\", GENERIC_WRITE, 0, 0, CREATE_ALWAYS, FILE_FLAG_OVERLAPPED, 0); //设置异步IO的标志FILE_FLAG_OVERLAPPED\nchar buffer[10] = {\"abcd\"};\nOVERLAPPED ol = { 0 };//用0初始化OVERLAPPED的结构\nol.Offset = 2;/从文件的第三个字节开始IO\nBOOL rt = WriteFile(hFile, buffer, 5, NULL, &ol);//发起一个异步写操作\n//SetFileCompletionNotificationModes(hFile, FILE_SKIP_SET_EVENT_ON_HANDLE);//如此设置则文件内核对象就不会被触发\nif (rt == FALSE && GetLastError() == ERROR_IO_PENDING)//检查异步IO是否完成 \n{\n\tWaitForSingleObject(hFile, INFINITE);//等待设备内核对象（文件）被触发。\n}\nCloseHandle(hFile);\n```\n\n##### GetOverlappedResult函数[[编辑](https://zh.wikipedia.org/w/index.php?title=%E5%BC%82%E6%AD%A5IO&action=edit&section=4)]\n\n也可以使用[Windows API](https://zh.wikipedia.org/wiki/Windows_API)函数GetOverlappedResult直接阻塞/非阻塞等待指定的异步IO操作是否完成。[[2\\]](https://zh.wikipedia.org/wiki/%E5%BC%82%E6%AD%A5IO#cite_note-2)该函数检查OVERLAPPED结构中的Internal成员的值是否为STATUS_PENDING来判断异步IO是否完成。\n\n##### 异步IO操作的完成通知用[事件](https://zh.wikipedia.org/wiki/%E4%BA%8B%E4%BB%B6_(%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD))内核对象[[编辑](https://zh.wikipedia.org/w/index.php?title=%E5%BC%82%E6%AD%A5IO&action=edit&section=5)]\n\n在异步IO操作的read/write函数调用中给出的OVERLAPPED类型的参数中，可以指定一个内核[事件](https://zh.wikipedia.org/wiki/%E4%BA%8B%E4%BB%B6_(%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD))对象。这个异步IO操作完成时，这个内核[事件](https://zh.wikipedia.org/wiki/%E4%BA%8B%E4%BB%B6_(%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD))对象会被触发。从而，等待在这个事件对象上的程序就会知道这个异步IO操作完成。\n\n例子：\n\n```\nHANDLE hFile = CreateFileW(L\"d:\\\\a.txt\", GENERIC_WRITE, 0, 0, CREATE_ALWAYS, FILE_FLAG_OVERLAPPED, 0); //设置异步IO的标志FILE_FLAG_OVERLAPPED\nchar buffer[10] = {\"abcd\"};\nOVERLAPPED ol = { 0 };//用0初始化OVERLAPPED的结构\nol.Offset = 2;/从文件的第三个字节开始IO\nHANDLE hEvent = CreateEvent(0, FALSE, FALSE, NULL);  \nol.hEvent = hEvent;//传递一个事件对象。  \n\nBOOL rt = WriteFile(hFile, buffer, 5, NULL, &ol);//发起一个异步写操作 \n\nif (rt == FALSE && GetLastError() == ERROR_IO_PENDING)//检查异步IO是否完成 \n{\n\tWaitForSingleObject(ol.hEvent, INFINITE);//等待设备内核对象（文件）被触发。\n}\nCloseHandle(hEvent); \nCloseHandle(hFile);\n```\n\n##### [可唤醒I/O](https://zh.wikipedia.org/wiki/%E5%8F%AF%E5%94%A4%E9%86%92I/O)[[编辑](https://zh.wikipedia.org/w/index.php?title=%E5%BC%82%E6%AD%A5IO&action=edit&section=6)]\n\n异步[可唤醒I/O](https://zh.wikipedia.org/wiki/%E5%8F%AF%E5%94%A4%E9%86%92I/O)操作通过ReadFileEx/WriteFileEx函数指出完成过程回调函数。回调函数在该线程的可唤醒等待（alertable wait）中被执行。\n\n##### [完成端口](https://zh.wikipedia.org/wiki/%E5%AE%8C%E6%88%90%E7%AB%AF%E5%8F%A3)[[编辑](https://zh.wikipedia.org/w/index.php?title=%E5%BC%82%E6%AD%A5IO&action=edit&section=7)]\n\n使用CreateIoCompletionPort函数创建一个[完成端口](https://zh.wikipedia.org/wiki/%E5%AE%8C%E6%88%90%E7%AB%AF%E5%8F%A3)。然后把文件句柄绑定到这个完成端口（通过CreateIoCompletionPort函数)。这个文件句柄上的异步IO操作完成时，会自动向这个完成完成端口发通知。线程通过GetQueuedCompletionStatus函数等待这个完成端口上的完成通知，然后从GetQueuedCompletionStatus的调用返回处恢复线程执行。\n\n##### [线程池](https://zh.wikipedia.org/wiki/%E7%BA%BF%E7%A8%8B%E6%B1%A0)I/O完成对象[[编辑](https://zh.wikipedia.org/w/index.php?title=%E5%BC%82%E6%AD%A5IO&action=edit&section=8)]\n\n使用CreateThreadpoolIo函数创建一个I/O完成对象，绑定了要执行异步I/O操作的文件句柄与待执行的回调函数。通过StartThreadpoolIo函数开始I/O完成对象的工作。每当绑定的文件句柄上的异步I/O操作完成，自动调用[线程池](https://zh.wikipedia.org/wiki/%E7%BA%BF%E7%A8%8B%E6%B1%A0)上的线程执行指定的回调函数。\n\n例子：\n\n```\nVOID CALLBACK OverlappedCompletionRoutine(PTP_CALLBACK_INSTANCE pInstance,  \n                                          PVOID pvContext,  \n                                          PVOID pOverlapped,  \n                                          ULONG IoResult,  \n                                          ULONG_PTR NumberOfBytesTransferred,  \n                                          PTP_IO pIo)  \n{  \n    printf(\"OverlappedCompletionRoutine, transferred: %d bytes\\n\", NumberOfBytesTransferred);  \n}  \n\nHANDLE hFile = CreateFileW(L\"d:\\\\a.txt\", GENERIC_WRITE, 0, 0, CREATE_ALWAYS, FILE_FLAG_OVERLAPPED, 0); //设置异步IO的标志FILE_FLAG_OVERLAPPED\n\nPTP_IO pio = CreateThreadpoolIo(hFile, OverlappedCompletionRoutine, NULL, NULL);//将设备对象和线程池的IO完成端口关联起来。  \nStartThreadpoolIo(pio);\nchar buffer[10] = {\"abcd\"};\nOVERLAPPED ol = { 0 };//用0初始化OVERLAPPED的结构\nol.Offset = 2;/从文件的第三个字节开始IO   \n\nBOOL rt = WriteFile(hFile, buffer, 5, NULL, &ol);//发起一个异步写操作 \nif(rt==FALSE && GetLastError()==ERROR_IO_PENDING))\n{  \n   ::Sleep(4000); \n   //do somethings... \n}\nelse\n{\n   CancelThreadpoolIo(pio); \n}\nWaitForThreadpoolIoCallbacks(pio,false);\nCloseHandle(hFile); \nCloseThreadpoolIo(pio);//关闭线程池io完成对象\n```\n\n#### 参见[[编辑](https://zh.wikipedia.org/w/index.php?title=%E5%BC%82%E6%AD%A5IO&action=edit&section=9)]\n\n- [IOCP](https://zh.wikipedia.org/wiki/IOCP)\n\n#### 参考文献[[编辑](https://zh.wikipedia.org/w/index.php?title=%E5%BC%82%E6%AD%A5IO&action=edit&section=10)]\n\n1. **^** [Description from .NET Framework Developer's Guide](http://msdn.microsoft.com/en-US/library/kztecsys%28v=vs.100%29.aspx)\n2. **^** [MSDN:GetOverlappedResult function](https://msdn.microsoft.com/en-us/library/windows/desktop/ms683209(v=vs.85).aspx)\n\n#### 外部链接[[编辑](https://zh.wikipedia.org/w/index.php?title=%E5%BC%82%E6%AD%A5IO&action=edit&section=11)]\n\n- [The C10K Problem](https://www.webcitation.org/6ICibHuyd?url=http://www.kegel.com/c10k.html); a survey of asynchronous I/O methods with emphasis on scaling – by Dan Kegel\n- Article \"[Boost application performance using asynchronous I/O](http://www.ibm.com/developerworks/library/l-async)\" by [M. Tim Jones](https://zh.wikipedia.org/w/index.php?title=M._Tim_Jones&action=edit&redlink=1)\n- Article \"[Lazy Asynchronous I/O For Event-Driven Servers](http://www.usenix.org/event/usenix04/tech/general/full_papers/elmeleegy/elmeleegy_html/html.html)\" by [Willy Zwaenepoel](https://zh.wikipedia.org/w/index.php?title=Willy_Zwaenepoel&action=edit&redlink=1), [Khaled Elmeleegy](https://zh.wikipedia.org/w/index.php?title=Khaled_Elmeleegy&action=edit&redlink=1), [Anupam Chanda](https://zh.wikipedia.org/w/index.php?title=Anupam_Chanda&action=edit&redlink=1) and [Alan L. Cox](https://zh.wikipedia.org/w/index.php?title=Alan_L._Cox&action=edit&redlink=1)\n- [Perform I/O Operations in Parallel](https://www.gnu.org/software/libc/manual/html_node/Asynchronous-I_002fO.html)\n- [Description from POSIX standard](http://opengroup.org/onlinepubs/009695399/basedefs/aio.h.html)\n- [Inside I/O Completion Ports](https://web.archive.org/web/20101101112358/http://doc.sch130.nsc.ru/www.sysinternals.com/ntw2k/info/comport.shtml) by [Mark Russinovich](https://zh.wikipedia.org/w/index.php?title=Mark_Russinovich&action=edit&redlink=1)\n- [Asynchronous I/O and The Asynchronous Disk I/O Explorer](http://www.flounder.com/asynchexplorer.htm)\n- [IO::AIO is a Perl module offering an asynchronous interface for most I/O operations](http://software.schmorp.de/pkg/IO-AIO.html)\n- [ACE Proactor](https://web.archive.org/web/20170623060116/http://www.cs.wustl.edu/~schmidt/PDF/proactor.pdf)\n\n### 解释\n\n从上面文献可以看出，异步IO大概就是发起IO的程序一直发起IO，不需要等待IO做出相应。\n\n# 有什么用\n\n### 从爬虫说起\n\n异步IO是我学习Python爬虫时候接触到的，所以先从爬虫说起。\n随着计算机性能的不断提升，程序运行速度不断提高，而限制程序运行速度的不再是计算机性能，而是IO速度，比如一个爬虫处理数据要20ms，而网络延迟60ms（这也是比较理想的速度了），这段时间Python闲的没事干，只能等待IO响应，计算机的性能没法发挥到极致。而异步IO只需程序一直发起IO，等响应来了再处理响应，大大提升了爬虫速度\n\n### 作用\n\n促进了爬虫事业发展，发挥了计算机应有性能\n\n# 什么哲学\n\n### 老电脑/手机卡顿表现在哪里\n\n大多数老旧设备卡顿是性能不够，CPU无法处理大量程序造成的\n\n### 怎么解决\n\n解决方法就是让老旧设备的性能发挥到极致，发挥到极致的方法除了超频以外还有一个妙法，这就是我要说的内容，这个方法就是充分利用老旧设备的IO等待时间，让老旧设备一直保持高频运转\n\n### 怎么操作\n\n这要说你是怎么判断你的设备卡顿了，你判断的依据一定是看到设备IO的output反应迟缓，但你没看到的是input正闲的没事干，此时你可以用脑子预测你将会需要按什么键，或者什么输入操作，给设备input，此时设备卡顿，所以你的input处于已接收未处理状态，因为CPU累的要死所以暂时不会处理input。而等待CPU处理完卡顿后刚准备歇会，就发现了你的input，于是就开始处理input，发挥到CPU的性能极致。\n这个实际上并不是CPU的异步，而是你脑子的异步，因为设备卡顿你并没有接收到设备给你的output，但你不等待output，直接进行下一个input，省去设备output然后你脑子处理再input给设备的时间，大大提升设备运行效率。\n\n# 最后\n\n提升老旧设备效率只是一个简单的异步哲学应用，生活中有很多异步哲学的应用，只要你能“运用自如”，工作效率提升的不是一点半点。\n\n","tags":["哲学"]},{"title":"优酸乳味的资源库","url":"/blog/2020/02/11/优酸乳味的资源库/","content":"\n经过lakphy的不懈努力，这个项目终于达到可以公开的程度了\n/一个人既是前端工程师又是录入员，既是UI设计师又是交互设计师，既是debugger又是文案，真的好南啊\n下面是海报\n![海报](post.jpg)\n\n## 这是什么\n\n这是一个资源站，上面的资源应有尽有，大多数都是免费的，电子书、电影、会员音乐、会员电视剧、在线工具、免费API、开源镜像站列表、热门排行榜、kindle电子书.......只要你能想到的，这上面都可以找到。\n\n## 为什么要做这样一个网站\n\n发现现在国内找资源很麻烦，上谷歌自然能找到，但并不是一直都能上啊，百度啥也没有，必应半吊子，聚合在一起多方便啊。所以我很久以前就着手做这个网站了，只是一开始是自己用，比较简陋，没打算给大家用。\n后来觉得这么好的资源网站，应该和大家一起分享，但太简陋拿不出手啊，于是就再次开工，完善网站，这也不简单，涉及适配性，版权声明等等方面。\n\n## 为什么叫优酸乳味的资源库？\n\n这也比较有意思了，起初网站是自用，名字随便起的，叫resource library，就是资源库的意思，但太长了，在小屏手机问题明显，影响美观，于是缩了缩。刚好有个关系特别好的朋友网名：优酸乳味的**。于是名字就缩成了SourLib，中文名优酸乳味的资源库，也是一个有故事的名字。\n\n## 链接？\n\n链接是[lakphy.me/res](https://lakphy.github.io/res)\n国内如果访问慢，就点[这里](https://lakphy.gitee.io/res)\n国内这个更新慢，因为有些网站没录完，所以建议点第一个链接，更新快。\n\n为什么链接目录是res？\n因为之前名字是resource library，所以目录res，也就没改\n\n## 规则提交\n\n优酸乳味的资源库长期接受资源提交，只需发送到我的邮箱即可：\nlakphy@outlook.com\n有任何版权问题或者网站不运转问题也可以联系我","tags":["资源库"]},{"title":"技术杂谈---几个月没更博客发生了什么","url":"/blog/2020/02/11/技术杂谈-几个月没更博客发生了什么/","content":"好长时间没有更新博客了，在这期间发生了什么？(´°̥̥̥̥̥̥̥̥ω°̥̥̥̥̥̥̥̥｀)\n## Why？没更新博客\n#### 因为高三了\n这是最重要的原因了，实在抽不出时间来写博客，（再说也没人看是吧(╥﹏╥)）\n#### 还有个悲伤的原因\n那就是我的电脑挂了，而我的博客只在我的电脑里有备份\n至于挂掉原因。。。。。\n\n一个悲惨的原因，我在安装Python的时候发现我的Python2和Python3的pip混了，没法使用，于是我就打算重装Python\n重装这东西emmm，Google一下吧，Google出来一个卸载软件及其依赖的包，我还想的卸载依赖的包是不是就是指的pip啊\n```\nsudo apt-get autoremove python\n```\n对，就是上面这个万恶的命令\n我输完命令，回车输root密码，回车，一气呵成，头也没抬，然后拿起了手机\n\n过了大概十分钟，感觉不对劲，卸个软件咋这么长时间啊\n抬头一看，这tm卸啥呢啊，咋一堆deepin-什么什么的包也卸了啊，在仔细看，底下咋把QQ卸了啊\n非常不对劲\n我赶紧一个Ctrl+Z，停止卸载，可惜为时已晚，大多数系统组件已经废掉了\n我一想，wc，卸载依赖，好像挺多软件依赖Python的啊呜呜呜\n赶紧想办法补救吧\n亏了dde桌面环境还在\n赶紧apt一下看看能不能装回来，发现我刚才有个Ctrl+Z把apt锁住了\n心里跑过一群草泥马\n赶紧去清华镜像站重装apt\nwoc，啥玩意，网卡驱动没了\n我tmd。。。。。\n没办法，备份，关机，第二天去学校做deepin启动盘吧\n亏了我备份时候记得把hexo配置备份了，不然估计等高考完才能更新博客\n###### 说个好玩的：移花接木大法\n我重装hexo时候，出现莫名错误，导致node_modules目录下的内容缺失，没法正常部署\n我灵机一动\n备份里不是有一份么，直接复制到行了\n于是一顿操作\n随着一个命令\n```\nhexo server\n```\n我竟然成功了，我真佩服我的脑子\n## 以后呢？\n以后吧，我会缓慢更新一些博客，一些奇奇怪怪的博客，当然不会是什么踩坑博客了，毕竟没有时间，当然也不是那么绝对啊。\n我会把一些想法写下来，我认为相当不错的想法，可以留到高考完实现\n## 最近关注了哪些方面\n#### Nginx\n给电脑装了个Nginx，预计以后会用到，以后，对，很久以后\n#### PHP\n简单了解了一下PHP，还不错，但并没有计划深入学习\n> PHP是最好的语言！\n（逃\n#### Golang\n研究了下go，发现这个语言离我有点远，目前没有需求\n#### Python外包软件\n因为刷知乎，所以了解到这个很赚钱，于是就去淘宝套了一个中介，问了下行情，打算高考完整一整，赚点钱买服务器，有助于后期研究，不然Golang永远都会离我很远（\n下面简单介绍下我了解到的行情\n> 一个微博搜索关键词的py程序，大概500，中介会抽取40-60%\n这对我来说比较理想，虽然我不知道程序猿行业是怎么样的，至少我觉得比较满意\n#### Arduino开发单片机\n这个东西不错，不到一天就入门了，打算抽时间做个badusb，另外还可以做一些浪漫的东西给小姐姐（划掉）\n计算了一下，如果给别人送礼物的话，大概是这样价格：\n```\nSTM32___15RMB以内\n蜂鸣器___3RMB以内\n电池_三节华泰够用了___2RMB（多送一节）\nLED___3RMB以内\n```\n保守算的话23RMB以内可以解决，还是比较实惠的\n\n#### live Linux\n想找一个满足自己需要，可以装在口袋里的Linux，作为随身使用，但找了一圈都没有适合的，看来只能自己用Arch配了，高考完再说吧\n\n#### 优酸乳味的资源库\n对，这就是我整了好长时间的资源库，资源贼多，现在基本可以公开了，但出于安全考虑，低调进行吧，人身安全和域名安全（防狙击）。\n起名的话，以前是resource library，为了适配小屏，缩短了名字，又刚好一个关系特别好的朋友wx和Q昵称叫优酸乳味的**，于是，这个名字就诞生了，奥对，英文名SourLib，就是从初始名字缩来的，因为初始名开头res所以网址没变[lakphy.me/res](https://lakphy.github.io/res)\n#### 换域名了啊\n忘了说这事了，以前后缀cf，现在me，这个我挑了老半天，就图这个me\n感谢wenzel Tian帮忙购买\n另外GoDaddy坑太深，以后千万别去，namecheap多香啊\n## emmm就是这么多了，祝高考顺利ᕦʕ •ᴥ•ʔᕤ\n","tags":["技术杂谈"]},{"title":"Hexo博客框架踩坑记录","url":"/blog/2019/06/09/Hexo博客框架踩坑记录/","content":"\n# 开始创建你的博客\n\n先为你的博客创建一个文件夹，这里不建议使用你的git文件夹，因为最终导出文件和这里要用的源文件不一样。\n\n## 前提条件\n\n确保你的设备上有以下几个软件包\n\nnodejs\n\nnpm\n\nvim\n\n如果没有，可以通过下面命令安装\n\n```\napt install //软件包名\n```\n\n## 安装hexo\n\n如果您的电脑中已经安装上述必备程序，那么恭喜您！接下来只需要使用 npm 即可完成 Hexo 的安装。\n\n```\nnpm install -g hexo-cli\n```\n\n# 正式开始建站   /逃(\n\n安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。\n\n```\nhexo init //文件夹目录\ncd //文件夹目录\n```\n\n新建完成后，指定文件夹的目录如下：\n\n```\n.\n├── _config.yml\n├── package.json\n├── scaffolds\n├── source\n|   ├── _drafts\n|   └── _posts\n└── themes\n```\n\n# 配置hexo\n\n下面开始配置hexo，这里只讲述初次使用者必需的部分，更多内容请访问[hexo官方网站](https://hexo.io)。\n\n您可以在 `_config.yml` 中修改大部分的配置。\n\n| 参数        | 描述                                        |\n| ----------- | ------------------------------------------- |\n| title       | 网站标题                                    |\n| subtitle    | 网站副标题                                  |\n| description | 网站描述                                    |\n| author      | 您的名字                                    |\n| language    | 网站使用的语言                              |\n| timezone    | 网站时区（默认根据您当前时区而定，无需设置) |\n\n其中，`description`主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。`author`参数用于主题显示文章的作者。\n\n| 参数                 | 描述                                                         | 默认值                      |\n| -------------------- | ------------------------------------------------------------ | --------------------------- |\n| `url`                | 网址                                                         |                             |\n| `root`               | 网站根目录                                                   |                             |\n| `permalink`          | 文章的 [永久链接](https://hexo.io/zh-cn/docs/permalinks) 格式 | `:year/:month/:day/:title/` |\n| `permalink_defaults` | 永久链接中各部分的默认值                                     |                             |\n\n#### 网站存放在子目录\n\n如果您的网站存放在子目录中，例如 `http://yoursite.com/blog`，则请将您的 `url` 设为 `http://yoursite.com/blog` 并把 `root` 设为 `/blog/`。\n\n# 创建您的第一条博文\n\n您的所有博文源文件都在/source/_posts/中，都通过ｍｄ语法编写\n\n```\nhexo new \"这里写博文名\"\n```\n\n通过上面命令可以创造一个新的博文，您可以使用ｍｄ语法编写博文\n\n# 部署网站\n\n通过下面命令部署您的博客到http://localhost:4000\n\n```\nhexo server\n```\n\n# 生成博客静态文件\n\n如果您需要生成静态文件以上传到ｇｉｔｈｕｂ，您可以通过以下命令生成静态文件\n\n```\nhexo generate\n```\n\n生成的静态文件将会出现在publish文件夹内，您可以将ｐｕｂｌｉｓｈ文件夹内内容直接复制到ｇｉｔｈｕｂ。\n\n# FAQ\n\n目前仅发现一个常见问题：\n\n在 `_config.yml` 中\n\n如果您的网站存放在子目录中，例如 `http://yoursite.com/blog`，则请将您的 `url` 设为 `http://yoursite.com/blog` 并把 `root` 设为 `/blog/`。\n\n# 关于主题\n\n我使用的主题为hexo-casper，在github star 排行榜中挺靠前，中文文档链接　https://zhih.me/hexo-casper-usage/\n\n使用方法在文档中将会有呈现\n\n# 完成\n\n至此，您已完成博客构建，感谢观看。","tags":["踩坑记录"]},{"title":"Github踩坑记录","url":"/blog/2019/06/09/Github踩坑记录/","content":"我在手机上使用github的时候遇到了不少坑，当然最后都使用搜索引擎解决了，为了免得自己遗忘，特作此博文。\n\n## 开始使用\n\n我的手机没有root（主力机不敢root），所以我的git在sd卡目录中，并专门设立一个叫1024的文件夹放git，如果你们的目录不一样，可以随意修改。\n\n```\napt install git\napt install vim\napt install openssh\n```\n\n以上代码用于安装所需基本工具。\n\n## 建立git目录\n\n首先要设置你的邮箱和名字，应该是要和GitHub上设置的相同。\n\n```\ngit config --global user.name \"your name\"\ngit config --global user.email \"email@example.com\"\n```\n\n上面的命令引号内替换为自己的名字和邮箱 下一步建立git仓库的目录\n\n先cd到想要放git的目录\n\n我的目录是/sdcard/1024，所以要用命令：\n\n```\ncd /sdcard/1024\n```\n\n使用下面的指令，让这个文件夹变为git可以管理的仓库（这个文件夹一定要是空的）\n\n```\ngit init\n```\n\n这个指令使用成功后，文件夹下会多出来一个.git的文件夹\n\n## 上传文件到仓库\n\n下面我们上传文件到仓库 第一步，\n\n使用git add 如果只添加某个文件，\n\n如example.txt，则使用：\n\n```\ngit add example.txt\n```\n\n如果想把文件夹内文件全部添加（包括子文件夹），则使用：\n\n```\ngit add .\n```\n\n第二步，上传到本地仓库\n\n```\ngit commit -m \"这里写日志\"\n```\n\n引号内写日志，不可省略或不写！！！\n\n至此，关于git的大部分内容已讲完，如想了解更多git工作的教程，请访问网站：[廖雪峰的网站](https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013743858312764dca7ad6d0754f76aa562e3789478044000)，这是我找到的介绍比较全的网站\n\n## 上传到远程仓库\n\n首先通过ssh连接远程仓库，以GitHub为例。 \n\n我们已经安装了openssh，所以可以通过以下指令获取ssh代码：\n\n```\nssh-keygen -t rsa -C \"email@example.com\"\n```\n\n同样，引号内写邮箱 \n\n然后根据它的提示，找到id_rsa.pub文件所在目录，用vim打开\n\n```\nvim //后面加id_rsa.pub的文件地址\n```\n\nvim会打开这个文件，将里面所有代码复制出来即可。\n退出vim：确保自己没瞎jb按，然后输:q退出。\n\n然后打开GitHub，新建仓库，进入设置，打开ssh keys，新建，然后随便写一个标题，复制代码进去，点确认，OK。\n\n然后使用指令：\n\n```\ngit remote add origin https://github.com/lakphy/text.git\n```\n\n其中，lakphy是我的github名，text是仓库名，自己根据自己实际情况作修改。\n\n然后使用指令：\n\n```\ngit pull origin master\ngit push origin master\n```\n\n## 完成\n\n打开github即可看到代码已经上传成功了！","tags":["踩坑记录"]},{"title":"第一篇博文","url":"/blog/2019/06/09/第一篇博文/","content":"这里是第一篇博文","tags":["水博文"]}]