[{"title":"deepin长期使用评测","url":"/blog/2020/02/15/deepin长期使用评测/","content":"\n由于一些不可抗拒的原因（主板莫名不兼容win）不得不选择Linux，试过多种Linux，deepin(深度操作系统)可以说是众多linux最省心好用的了。\n\n[深度操作系统官网](https://deepin.org)\n\n[深度官网](https://deepin.com/)\n\n# 如何发现这么好的系统的\n\n### 首先支持国产\n\n这个当然的，国产的好东西必须大力支持！\n\n### 国际排名高\n\n这个不多说，大众的眼睛是雪亮的，看下排名就知道啦：\n\n[排名链接](https://distrowatch.com/dwres.php?resource=popularity)\n\n![](1.png)\n\n可以看到的deepin基本稳定在第十名，注意现在时间2020年02月15日。\n\n最近疫情原因很长时间没有维护了，排名有所下降属于正常现象。\n\n记得最高排第六。\n\n### 软件生态\n\n其实我是冲软件生态来的\n\n软件生态是一个操作系统的灵魂，没有软件生态，它就不配叫操作系统，那叫啥？可能叫嵌入式系统？功能机？（Lumia警告）\n\nMicrosoft，Google，Apple都为他们操作系统生态投入了大量资金和人员，包括学生组织开发活动，软件竞赛之类的活动，或是直接给钱，足以突显软件生态的重要性。\n\n众所周知，Windows系统的整体操作逻辑已经十几年没变了，而且易用性越来越差，在众多现代操作系统中处于劣势，但为什么Windows用户永远不会降低呢，这也是软件生态的效果，Windows下的软件生态非常庞大，难以超越，这也表现了当初微软在中国地区容忍盗版泛滥现象的战略意义。\n\n好了好了，有点偏题了。\n\n下面说deepin的软件生态：\n\n1. Deepin基于Debian GNU/Linux，支持Linux软件，Debian特有的deb软件，以及Debian著名的apt包管理系统\n2. 预装wine，通过底层代码适配大量Windows软件\n3. 深度团队对于不支持wine的Windows软件进行专门适配，这个是其他发行版装了wine也比不上了的。像Windows QQ就是专门适配的，比QQ官方发布的Linux版好用\n4. 预装Chrome，支持webAPP，ChromeOS软件，安卓软件\n\n可见这软件生态真的是太强了\n\n这是GNU/Linux里生态强的，据说还有个国产的ChromeOS生态也贼强（国产都喜欢玩全平台适配？），没用过，叫fydeOS，可以去尝试一下。\n\n这个生态空口无凭，看下例子\n\n![](2.png)\n\n上面这个是应用商店，很多是深度团队自己适配来的，很良心了。\n\n![](3.png)\n\n上面这个是QQ官方的Linux版，可以看出来界面相当远古了，而且看那大小也不像好东西\n\n![](4.png)\n\n这个是wine版QQ，深度团队专门适配过的，版本也比较新，但最近好像是疫情原因还没给适配下一版本。\n\n![](5.png)\n\n上面这是应用商店里编程开发专区，可以看到这里特殊适配的就少了，毕竟开发用的软件还是给做Linux版的\n\n这里说个有意思的，深度团队还把著名游戏平台steam整来了，如下图：\n\n![](6.png)\n\n这就很厉害了，据说还能玩GTA呢\n\n下面这个是下载排行榜：（偷偷说个事：Linux版百度云不限速！）\n\n![](7.png)\n\n# 使用体验\n\n整体使用体验不错，高斯模糊运用得当\n\n### 桌面\n\n##### 桌面总览![](8.png)\n\n请无视我桌面的文件谢谢（\n\n##### dock栏\n\ndock可以设置成MacOS样式或Windows样式，非常友好\n\n![](9.png)\n\n上面这是仿win，即高效样式\n\n![](10.png)\n\n上面这个是仿MacOS样式，即潮流样式\n\n我使用的是高效样式，之后将使用高效样式演示，潮流样式类似\n\n##### 硬盘管理器\n\n![11](11.png)\n\n##### WiFi\n\n![](12.png)\n\n##### 应用列表\n\n![](13.png)\n\n这个也有两种风格，这个是仿win的，下面这个是仿MacOS的\n\n![](14.png)\n\n##### 工作区总览\n\n![](15.png)\n\n### 设置界面\n\n这里是通知界面，点右上角切换设置\n\n![](16.png)\n\n设置总览：\n\n![17](17.png)\n\n下面把整个设置截屏看看\n\n![18](18.png)\n\n\n\n![19](19.png)\n\n![20](20.png)\n\n![21](21.png)\n\n![22](22.png)\n\n![23](23.png)\n\n值得一提的是，deepin自带一个开机引导选项，非常方便\n\n![25](25.png)\n\n### 终端\n\n这终端和普通GNU/Linux终端一样，没有区别\n\n![26](26.png)\n\n### 文件管理器\n\n![27](27.png)\n\n### Chrome\n\n![28](28.png)\n\n### 电源选项\n\n![29](29.png)\n\n### 资源管理器\n\n![30](30.png)\n\n# 其他软件\n\n这里推荐几个有用的软件\n\n### 连接手机\n\n我用kdeconnect连接手机，堪比airdrop，十分好用\n\n![32](32.png)\n\n![31](31.png)\n\n### 那些你懂的飞机\n\n这个我用clash，github上有，配置有点复杂，但好用\n\n### 打代码\n\n##### VSCode\n\n![33](33.png)\n\n##### sublime text\n\n![34](34.png)\n\n# 结尾\n\n以上是我简单对deepin的评测，十分好用，目前我已使用一年多了，没什么大问题（除了上次我不小心输错命令把软件全删了），希望这个国产操作系统可以越做越好。\n","tags":["评测"]},{"title":"linux如何快速备份","url":"/blog/2020/02/13/linux如何快速备份/","content":"\n我现在使用的是deepin linux，自带备份功能，但总感觉这个备份有点。。。。\n\n> Talk is cheap,show me the screenshot。\n\n直接看图吧，备注现在时间2020-02-13（\n\n![看这时间多悠久](2.png)\n\n好像从第一次注册完账号开启自动备份后就没开过。。。\n\n我这还算好的，最起码有个界面，那些用其他发行版的大牛们怎么办啊，全盘备份？没这必要吧，只要备份重要配置文件就够了，再说全盘备份要是碰上Linus那种只用固态硬盘的硬盘就遭殃了。\n\n突然想起来Linux有批处理功能，于是打开vim和Google，开工！\n\n# 编写程序\n\n## 基本思路\n\n这里说一下备份思路\n\n1. 把重要文件（夹）复制到临时目录（因为是机械硬盘无所谓寿命）\n2. 打包成zip\n3. 移动到u盘里\n\n## 第一个功能：计时\n\n这功能真的是强迫症福音啊，废话少说放码：\n\n```\nstart=$(date \"+%s\")\t#记录开始时间\n#这里运行代码\nnow=$(date \"+%s\")\t#记录结束时间\ntime=$((now-start))\t#计算用时\necho \"time used:$time seconds\"\t#输出时间\n#echo $date\n```\n\n就这样一个计时功能出来了，果然比某某些编程语言简单，像某语言还要引用time（逃\n\n对了，科普一下，shell里输出是\n\n```\necho \"exampleString\"\t#输出文字\necho $someVar\t#输出变量\n```\n\n我测试了一下，没有代码时候输出0s，还是挺准的  :D\n\n## 建立备份临时文件夹\n\n此步在硬盘中建立临时备份文件夹，命名为当前时间\n\n建立文件夹应该都会吧，所以直接上代码\n\n```\ndate=$(date +%Y%m%d%H%m%s)\t#获取时间\nmkdir /media/lakphy/DATA/baks/$date\t#建立文件夹\n```\n\n## 建立重要文件夹名单\n\n此步建立一个数组（我习惯将列表说成数组，意义相同，以后不做解释），里面放有重要文件（夹）通报（划掉）名单\n\n```\ncopyPath=(\t#这是建立数组的代码\n\t'/home/lakphy/lakphy/golang'\n\t'/home/lakphy/lakphy/py'\n\t'/home/lakphy/lakphy/nodejs'\n\t'/home/lakphy/Downloads'\n\t'/media/lakphy/DATA/downloads'\n\t'/home/lakphy/Desktop'\n\t)\t#这是我的重要文件目录，仅示例使用\n```\n\n## 复制内容到临时备份文件夹\n\n这里利用循环遍历重要文件（夹）名单复制，这个操作我们在学习Python时候应该都学过\n\n```\nfor p in ${copyPath[@]}\t#for循环\ndo\t#循环开始符\n\techo 'copying '$p\t#输出复制信息\n\tcp -r $p /media/lakphy/DATA/baks/$date\t#Linux cp命令玄学复制，速度贼快\ndone\t#循环结束符\n```\n\n## 压缩\n\n```\npathname='/media/lakphy/DATA/baks/'$date\t#备份文件夹路径  date是我们之前定义的时间\nzipname='/media/lakphy/DATA/baks/'$date\t\t#压缩文件路径和名字\nzip -r $zipname $pathname\t\t\t\t\t#压缩命令\n```\n\n## 移动到批处理程序所在目录\n\nmv命令，这个比较简单，不解释\n\n# 完整代码\n\n来看下完整代码\n\n## codes\n\n```\n\n```\n\n\n\n## 运行\n\n保存为backup.sh\n\n如果程序在电脑上的话，直接双击或者命令:\n\n```\n./backup.sh\n```\n\n如果在外部存储器上，只能在命令行运行，命令只能是：\n\n```\nbash backup.sh\n```\n\nbash意思是解释器为bash，至于为什么是bash不是shell，这个我也不懂，我谷歌的时候写的shell啊。。。但shell真的运行不了，不信试试：\n\n```\nshell backup.sh\n```\n\n至于内部外部存储器区别，我觉得可能是外部存储器文件系统不是ext4不能加可执行权限问题\n\n我运行了一下，速度不错，比直接复制快，毕竟cp命令玄学复制，430s完成。","tags":["bash"]},{"title":"异步的哲学---旧电脑也能运用自如？","url":"/blog/2020/02/12/异步的哲学-旧电脑也能运用自如？/","content":"\n先说一句，这篇博文是瞎讨论哲学用的（\n\n# 什么是异步\n\n### 来自Wikipedia的解释（异步IO）\n\n[[原文链接](<https://zh.wikipedia.org/wiki/%E5%BC%82%E6%AD%A5IO>)]\n\n**异步IO**是计算机操作系统对[输入输出](https://zh.wikipedia.org/wiki/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA)的一种处理方式：发起IO请求的线程不等IO操作完成，就继续执行随后的代码，IO结果用其他方式通知发起IO请求的程序。与异步IO相对的是更为常见的“同步（阻塞）IO”：发起IO请求的线程不从正在调用的IO操作函数返回（即被阻塞），直至IO操作完成。\n\n#### 类Unix操作系统与POSIX[[编辑](https://zh.wikipedia.org/w/index.php?title=%E5%BC%82%E6%AD%A5IO&action=edit&section=1)]\n\nPOSIX提供下述API函数：\n\n|      | 阻塞        | 非阻塞                      |\n| ---- | ----------- | --------------------------- |\n| 同步 | write, read | write, read + poll / select |\n| 异步 | -           | aio_write, aio_read         |\n\n#### Windows操作系统的异步IO[[编辑](https://zh.wikipedia.org/w/index.php?title=%E5%BC%82%E6%AD%A5IO&action=edit&section=2)]\n\nWindows提供多种异步IO（也称[重叠IO](https://zh.wikipedia.org/wiki/%E9%87%8D%E5%8F%A0I/O)）方式：[[1\\]](https://zh.wikipedia.org/wiki/%E5%BC%82%E6%AD%A5IO#cite_note-1)\n\n##### 设备内核对象[[编辑](https://zh.wikipedia.org/w/index.php?title=%E5%BC%82%E6%AD%A5IO&action=edit&section=3)]\n\nIO设备在操作系统内核中表示为[内核对象](https://zh.wikipedia.org/wiki/%E5%86%85%E6%A0%B8%E5%AF%B9%E8%B1%A1)，因此具有可等待（waitable）内核对象状态。例如：文件[句柄](https://zh.wikipedia.org/wiki/%E5%8F%A5%E6%9F%84)，线程句柄等等。对于文件内核对象，当一个异步IO完成后，该文件句柄被置为触发态。使用这种方式获取异步IO完成的通知，缺点是如果在一个文件内核对象上同时有多个异步IO操作，只通过文件句柄的触发无法辨识哪个异步IO操作完成了。\n\n例子：\n\n```\nHANDLE hFile = CreateFileW(L\"d:\\\\a.txt\", GENERIC_WRITE, 0, 0, CREATE_ALWAYS, FILE_FLAG_OVERLAPPED, 0); //设置异步IO的标志FILE_FLAG_OVERLAPPED\nchar buffer[10] = {\"abcd\"};\nOVERLAPPED ol = { 0 };//用0初始化OVERLAPPED的结构\nol.Offset = 2;/从文件的第三个字节开始IO\nBOOL rt = WriteFile(hFile, buffer, 5, NULL, &ol);//发起一个异步写操作\n//SetFileCompletionNotificationModes(hFile, FILE_SKIP_SET_EVENT_ON_HANDLE);//如此设置则文件内核对象就不会被触发\nif (rt == FALSE && GetLastError() == ERROR_IO_PENDING)//检查异步IO是否完成 \n{\n\tWaitForSingleObject(hFile, INFINITE);//等待设备内核对象（文件）被触发。\n}\nCloseHandle(hFile);\n```\n\n##### GetOverlappedResult函数[[编辑](https://zh.wikipedia.org/w/index.php?title=%E5%BC%82%E6%AD%A5IO&action=edit&section=4)]\n\n也可以使用[Windows API](https://zh.wikipedia.org/wiki/Windows_API)函数GetOverlappedResult直接阻塞/非阻塞等待指定的异步IO操作是否完成。[[2\\]](https://zh.wikipedia.org/wiki/%E5%BC%82%E6%AD%A5IO#cite_note-2)该函数检查OVERLAPPED结构中的Internal成员的值是否为STATUS_PENDING来判断异步IO是否完成。\n\n##### 异步IO操作的完成通知用[事件](https://zh.wikipedia.org/wiki/%E4%BA%8B%E4%BB%B6_(%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD))内核对象[[编辑](https://zh.wikipedia.org/w/index.php?title=%E5%BC%82%E6%AD%A5IO&action=edit&section=5)]\n\n在异步IO操作的read/write函数调用中给出的OVERLAPPED类型的参数中，可以指定一个内核[事件](https://zh.wikipedia.org/wiki/%E4%BA%8B%E4%BB%B6_(%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD))对象。这个异步IO操作完成时，这个内核[事件](https://zh.wikipedia.org/wiki/%E4%BA%8B%E4%BB%B6_(%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD))对象会被触发。从而，等待在这个事件对象上的程序就会知道这个异步IO操作完成。\n\n例子：\n\n```\nHANDLE hFile = CreateFileW(L\"d:\\\\a.txt\", GENERIC_WRITE, 0, 0, CREATE_ALWAYS, FILE_FLAG_OVERLAPPED, 0); //设置异步IO的标志FILE_FLAG_OVERLAPPED\nchar buffer[10] = {\"abcd\"};\nOVERLAPPED ol = { 0 };//用0初始化OVERLAPPED的结构\nol.Offset = 2;/从文件的第三个字节开始IO\nHANDLE hEvent = CreateEvent(0, FALSE, FALSE, NULL);  \nol.hEvent = hEvent;//传递一个事件对象。  \n\nBOOL rt = WriteFile(hFile, buffer, 5, NULL, &ol);//发起一个异步写操作 \n\nif (rt == FALSE && GetLastError() == ERROR_IO_PENDING)//检查异步IO是否完成 \n{\n\tWaitForSingleObject(ol.hEvent, INFINITE);//等待设备内核对象（文件）被触发。\n}\nCloseHandle(hEvent); \nCloseHandle(hFile);\n```\n\n##### [可唤醒I/O](https://zh.wikipedia.org/wiki/%E5%8F%AF%E5%94%A4%E9%86%92I/O)[[编辑](https://zh.wikipedia.org/w/index.php?title=%E5%BC%82%E6%AD%A5IO&action=edit&section=6)]\n\n异步[可唤醒I/O](https://zh.wikipedia.org/wiki/%E5%8F%AF%E5%94%A4%E9%86%92I/O)操作通过ReadFileEx/WriteFileEx函数指出完成过程回调函数。回调函数在该线程的可唤醒等待（alertable wait）中被执行。\n\n##### [完成端口](https://zh.wikipedia.org/wiki/%E5%AE%8C%E6%88%90%E7%AB%AF%E5%8F%A3)[[编辑](https://zh.wikipedia.org/w/index.php?title=%E5%BC%82%E6%AD%A5IO&action=edit&section=7)]\n\n使用CreateIoCompletionPort函数创建一个[完成端口](https://zh.wikipedia.org/wiki/%E5%AE%8C%E6%88%90%E7%AB%AF%E5%8F%A3)。然后把文件句柄绑定到这个完成端口（通过CreateIoCompletionPort函数)。这个文件句柄上的异步IO操作完成时，会自动向这个完成完成端口发通知。线程通过GetQueuedCompletionStatus函数等待这个完成端口上的完成通知，然后从GetQueuedCompletionStatus的调用返回处恢复线程执行。\n\n##### [线程池](https://zh.wikipedia.org/wiki/%E7%BA%BF%E7%A8%8B%E6%B1%A0)I/O完成对象[[编辑](https://zh.wikipedia.org/w/index.php?title=%E5%BC%82%E6%AD%A5IO&action=edit&section=8)]\n\n使用CreateThreadpoolIo函数创建一个I/O完成对象，绑定了要执行异步I/O操作的文件句柄与待执行的回调函数。通过StartThreadpoolIo函数开始I/O完成对象的工作。每当绑定的文件句柄上的异步I/O操作完成，自动调用[线程池](https://zh.wikipedia.org/wiki/%E7%BA%BF%E7%A8%8B%E6%B1%A0)上的线程执行指定的回调函数。\n\n例子：\n\n```\nVOID CALLBACK OverlappedCompletionRoutine(PTP_CALLBACK_INSTANCE pInstance,  \n                                          PVOID pvContext,  \n                                          PVOID pOverlapped,  \n                                          ULONG IoResult,  \n                                          ULONG_PTR NumberOfBytesTransferred,  \n                                          PTP_IO pIo)  \n{  \n    printf(\"OverlappedCompletionRoutine, transferred: %d bytes\\n\", NumberOfBytesTransferred);  \n}  \n\nHANDLE hFile = CreateFileW(L\"d:\\\\a.txt\", GENERIC_WRITE, 0, 0, CREATE_ALWAYS, FILE_FLAG_OVERLAPPED, 0); //设置异步IO的标志FILE_FLAG_OVERLAPPED\n\nPTP_IO pio = CreateThreadpoolIo(hFile, OverlappedCompletionRoutine, NULL, NULL);//将设备对象和线程池的IO完成端口关联起来。  \nStartThreadpoolIo(pio);\nchar buffer[10] = {\"abcd\"};\nOVERLAPPED ol = { 0 };//用0初始化OVERLAPPED的结构\nol.Offset = 2;/从文件的第三个字节开始IO   \n\nBOOL rt = WriteFile(hFile, buffer, 5, NULL, &ol);//发起一个异步写操作 \nif(rt==FALSE && GetLastError()==ERROR_IO_PENDING))\n{  \n   ::Sleep(4000); \n   //do somethings... \n}\nelse\n{\n   CancelThreadpoolIo(pio); \n}\nWaitForThreadpoolIoCallbacks(pio,false);\nCloseHandle(hFile); \nCloseThreadpoolIo(pio);//关闭线程池io完成对象\n```\n\n#### 参见[[编辑](https://zh.wikipedia.org/w/index.php?title=%E5%BC%82%E6%AD%A5IO&action=edit&section=9)]\n\n- [IOCP](https://zh.wikipedia.org/wiki/IOCP)\n\n#### 参考文献[[编辑](https://zh.wikipedia.org/w/index.php?title=%E5%BC%82%E6%AD%A5IO&action=edit&section=10)]\n\n1. **^** [Description from .NET Framework Developer's Guide](http://msdn.microsoft.com/en-US/library/kztecsys%28v=vs.100%29.aspx)\n2. **^** [MSDN:GetOverlappedResult function](https://msdn.microsoft.com/en-us/library/windows/desktop/ms683209(v=vs.85).aspx)\n\n#### 外部链接[[编辑](https://zh.wikipedia.org/w/index.php?title=%E5%BC%82%E6%AD%A5IO&action=edit&section=11)]\n\n- [The C10K Problem](https://www.webcitation.org/6ICibHuyd?url=http://www.kegel.com/c10k.html); a survey of asynchronous I/O methods with emphasis on scaling – by Dan Kegel\n- Article \"[Boost application performance using asynchronous I/O](http://www.ibm.com/developerworks/library/l-async)\" by [M. Tim Jones](https://zh.wikipedia.org/w/index.php?title=M._Tim_Jones&action=edit&redlink=1)\n- Article \"[Lazy Asynchronous I/O For Event-Driven Servers](http://www.usenix.org/event/usenix04/tech/general/full_papers/elmeleegy/elmeleegy_html/html.html)\" by [Willy Zwaenepoel](https://zh.wikipedia.org/w/index.php?title=Willy_Zwaenepoel&action=edit&redlink=1), [Khaled Elmeleegy](https://zh.wikipedia.org/w/index.php?title=Khaled_Elmeleegy&action=edit&redlink=1), [Anupam Chanda](https://zh.wikipedia.org/w/index.php?title=Anupam_Chanda&action=edit&redlink=1) and [Alan L. Cox](https://zh.wikipedia.org/w/index.php?title=Alan_L._Cox&action=edit&redlink=1)\n- [Perform I/O Operations in Parallel](https://www.gnu.org/software/libc/manual/html_node/Asynchronous-I_002fO.html)\n- [Description from POSIX standard](http://opengroup.org/onlinepubs/009695399/basedefs/aio.h.html)\n- [Inside I/O Completion Ports](https://web.archive.org/web/20101101112358/http://doc.sch130.nsc.ru/www.sysinternals.com/ntw2k/info/comport.shtml) by [Mark Russinovich](https://zh.wikipedia.org/w/index.php?title=Mark_Russinovich&action=edit&redlink=1)\n- [Asynchronous I/O and The Asynchronous Disk I/O Explorer](http://www.flounder.com/asynchexplorer.htm)\n- [IO::AIO is a Perl module offering an asynchronous interface for most I/O operations](http://software.schmorp.de/pkg/IO-AIO.html)\n- [ACE Proactor](https://web.archive.org/web/20170623060116/http://www.cs.wustl.edu/~schmidt/PDF/proactor.pdf)\n\n### 解释\n\n从上面文献可以看出，异步IO大概就是发起IO的程序一直发起IO，不需要等待IO做出相应。\n\n# 有什么用\n\n### 从爬虫说起\n\n异步IO是我学习Python爬虫时候接触到的，所以先从爬虫说起。\n随着计算机性能的不断提升，程序运行速度不断提高，而限制程序运行速度的不再是计算机性能，而是IO速度，比如一个爬虫处理数据要20ms，而网络延迟60ms（这也是比较理想的速度了），这段时间Python闲的没事干，只能等待IO响应，计算机的性能没法发挥到极致。而异步IO只需程序一直发起IO，等响应来了再处理响应，大大提升了爬虫速度\n\n### 作用\n\n促进了爬虫事业发展，发挥了计算机应有性能\n\n# 什么哲学\n\n### 老电脑/手机卡顿表现在哪里\n\n大多数老旧设备卡顿是性能不够，CPU无法处理大量程序造成的\n\n### 怎么解决\n\n解决方法就是让老旧设备的性能发挥到极致，发挥到极致的方法除了超频以外还有一个妙法，这就是我要说的内容，这个方法就是充分利用老旧设备的IO等待时间，让老旧设备一直保持高频运转\n\n### 怎么操作\n\n这要说你是怎么判断你的设备卡顿了，你判断的依据一定是看到设备IO的output反应迟缓，但你没看到的是input正闲的没事干，此时你可以用脑子预测你将会需要按什么键，或者什么输入操作，给设备input，此时设备卡顿，所以你的input处于已接收未处理状态，因为CPU累的要死所以暂时不会处理input。而等待CPU处理完卡顿后刚准备歇会，就发现了你的input，于是就开始处理input，发挥到CPU的性能极致。\n这个实际上并不是CPU的异步，而是你脑子的异步，因为设备卡顿你并没有接收到设备给你的output，但你不等待output，直接进行下一个input，省去设备output然后你脑子处理再input给设备的时间，大大提升设备运行效率。\n\n# 最后\n\n提升老旧设备效率只是一个简单的异步哲学应用，生活中有很多异步哲学的应用，只要你能“运用自如”，工作效率提升的不是一点半点。\n\n","tags":["哲学"]},{"title":"优酸乳味的资源站","url":"/blog/2020/02/11/优酸乳味的资源站/","content":"\n经过lakphy的不懈努力，这个项目终于达到可以公开的程度了\n/一个人既是前端工程师又是录入员，既是UI设计师又是交互设计师，既是debugger又是文案，真的好南啊\n下面是海报\n![海报](post.jpg)\n\n## 这是什么\n\n这是一个资源站，上面的资源应有尽有，大多数都是免费的，电子书、电影、会员音乐、会员电视剧、在线工具、免费API、开源镜像站列表、热门排行榜、kindle电子书.......只要你能想到的，这上面都可以找到。\n\n## 为什么要做这样一个网站\n\n发现现在国内找资源很麻烦，上谷歌自然能找到，但并不是一直都能上啊，百度啥也没有，必应半吊子，聚合在一起多方便啊。所以我很久以前就着手做这个网站了，只是一开始是自己用，比较简陋，没打算给大家用。\n后来觉得这么好的资源网站，应该和大家一起分享，但太简陋拿不出手啊，于是就再次开工，完善网站，这也不简单，涉及适配性，版权声明等等方面。\n\n## 为什么叫优酸乳味的资源库？\n\n这也比较有意思了，起初网站是自用，名字随便起的，叫resource library，就是资源库的意思，但太长了，在小屏手机问题明显，影响美观，于是缩了缩。刚好有个关系特别好的朋友网名：优酸乳味的**。于是名字就缩成了SourLib，中文名优酸乳味的资源库，也是一个有故事的名字。\n\n## 链接？\n\n链接是[lakphy.me/res](https://lakphy.github.io/res)\n国内如果访问慢，就点[这里](https://lakphy.gitee.io/res)\n国内这个更新慢，因为有些网站没录完，所以建议点第一个链接，更新快。\n\n为什么链接目录是res？\n因为之前名字是resource library，所以目录res，也就没改\n\n## 规则提交\n\n优酸乳味的资源库长期接受资源提交，只需发送到我的邮箱即可：\nlakphy@outlook.com\n有任何版权问题或者网站不运转问题也可以联系我","tags":["资源站"]},{"title":"技术杂谈---几个月没更博客发生了什么","url":"/blog/2020/02/11/技术杂谈-几个月没更博客发生了什么/","content":"好长时间没有更新博客了，在这期间发生了什么？(´°̥̥̥̥̥̥̥̥ω°̥̥̥̥̥̥̥̥｀)\n## Why？没更新博客\n#### 因为高三了\n这是最重要的原因了，实在抽不出时间来写博客，（再说也没人看是吧(╥﹏╥)）\n#### 还有个悲伤的原因\n那就是我的电脑挂了，而我的博客只在我的电脑里有备份\n至于挂掉原因。。。。。\n\n一个悲惨的原因，我在安装Python的时候发现我的Python2和Python3的pip混了，没法使用，于是我就打算重装Python\n重装这东西emmm，Google一下吧，Google出来一个卸载软件及其依赖的包，我还想的卸载依赖的包是不是就是指的pip啊\n```\nsudo apt-get autoremove python\n```\n对，就是上面这个万恶的命令\n我输完命令，回车输root密码，回车，一气呵成，头也没抬，然后拿起了手机\n\n过了大概十分钟，感觉不对劲，卸个软件咋这么长时间啊\n抬头一看，这tm卸啥呢啊，咋一堆deepin-什么什么的包也卸了啊，在仔细看，底下咋把QQ卸了啊\n非常不对劲\n我赶紧一个Ctrl+Z，停止卸载，可惜为时已晚，大多数系统组件已经废掉了\n我一想，wc，卸载依赖，好像挺多软件依赖Python的啊呜呜呜\n赶紧想办法补救吧\n亏了dde桌面环境还在\n赶紧apt一下看看能不能装回来，发现我刚才有个Ctrl+Z把apt锁住了\n心里跑过一群草泥马\n赶紧去清华镜像站重装apt\nwoc，啥玩意，网卡驱动没了\n我tmd。。。。。\n没办法，备份，关机，第二天去学校做deepin启动盘吧\n亏了我备份时候记得把hexo配置备份了，不然估计等高考完才能更新博客\n###### 说个好玩的：移花接木大法\n我重装hexo时候，出现莫名错误，导致node_modules目录下的内容缺失，没法正常部署\n我灵机一动\n备份里不是有一份么，直接复制到行了\n于是一顿操作\n随着一个命令\n```\nhexo server\n```\n我竟然成功了，我真佩服我的脑子\n## 以后呢？\n以后吧，我会缓慢更新一些博客，一些奇奇怪怪的博客，当然不会是什么踩坑博客了，毕竟没有时间，当然也不是那么绝对啊。\n我会把一些想法写下来，我认为相当不错的想法，可以留到高考完实现\n## 最近关注了哪些方面\n#### Nginx\n给电脑装了个Nginx，预计以后会用到，以后，对，很久以后\n#### PHP\n简单了解了一下PHP，还不错，但并没有计划深入学习\n> PHP是最好的语言！\n（逃\n#### Golang\n研究了下go，发现这个语言离我有点远，目前没有需求\n#### Python外包软件\n因为刷知乎，所以了解到这个很赚钱，于是就去淘宝套了一个中介，问了下行情，打算高考完整一整，赚点钱买服务器，有助于后期研究，不然Golang永远都会离我很远（\n下面简单介绍下我了解到的行情\n> 一个微博搜索关键词的py程序，大概500，中介会抽取40-60%\n这对我来说比较理想，虽然我不知道程序猿行业是怎么样的，至少我觉得比较满意\n#### Arduino开发单片机\n这个东西不错，不到一天就入门了，打算抽时间做个badusb，另外还可以做一些浪漫的东西给小姐姐（划掉）\n计算了一下，如果给别人送礼物的话，大概是这样价格：\n```\nSTM32___15RMB以内\n蜂鸣器___3RMB以内\n电池_三节华泰够用了___2RMB（多送一节）\nLED___3RMB以内\n```\n保守算的话23RMB以内可以解决，还是比较实惠的\n\n#### live Linux\n想找一个满足自己需要，可以装在口袋里的Linux，作为随身使用，但找了一圈都没有适合的，看来只能自己用Arch配了，高考完再说吧\n\n#### 优酸乳味的资源库\n对，这就是我整了好长时间的资源库，资源贼多，现在基本可以公开了，但出于安全考虑，低调进行吧，人身安全和域名安全（防狙击）。\n起名的话，以前是resource library，为了适配小屏，缩短了名字，又刚好一个关系特别好的朋友wx和Q昵称叫优酸乳味的**，于是，这个名字就诞生了，奥对，英文名SourLib，就是从初始名字缩来的，因为初始名开头res所以网址没变[lakphy.me/res](https://lakphy.github.io/res)\n#### 换域名了啊\n忘了说这事了，以前后缀cf，现在me，这个我挑了老半天，就图这个me\n感谢wenzel Tian帮忙购买\n另外GoDaddy坑太深，以后千万别去，namecheap多香啊\n## emmm就是这么多了，祝高考顺利ᕦʕ •ᴥ•ʔᕤ\n","tags":["技术杂谈"]},{"title":"Hexo博客框架踩坑记录","url":"/blog/2019/06/09/Hexo博客框架踩坑记录/","content":"\n# 开始创建你的博客\n\n先为你的博客创建一个文件夹，这里不建议使用你的git文件夹，因为最终导出文件和这里要用的源文件不一样。\n\n## 前提条件\n\n确保你的设备上有以下几个软件包\n\nnodejs\n\nnpm\n\nvim\n\n如果没有，可以通过下面命令安装\n\n```\napt install //软件包名\n```\n\n## 安装hexo\n\n如果您的电脑中已经安装上述必备程序，那么恭喜您！接下来只需要使用 npm 即可完成 Hexo 的安装。\n\n```\nnpm install -g hexo-cli\n```\n\n# 正式开始建站   /逃(\n\n安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。\n\n```\nhexo init //文件夹目录\ncd //文件夹目录\n```\n\n新建完成后，指定文件夹的目录如下：\n\n```\n.\n├── _config.yml\n├── package.json\n├── scaffolds\n├── source\n|   ├── _drafts\n|   └── _posts\n└── themes\n```\n\n# 配置hexo\n\n下面开始配置hexo，这里只讲述初次使用者必需的部分，更多内容请访问[hexo官方网站](https://hexo.io)。\n\n您可以在 `_config.yml` 中修改大部分的配置。\n\n| 参数        | 描述                                        |\n| ----------- | ------------------------------------------- |\n| title       | 网站标题                                    |\n| subtitle    | 网站副标题                                  |\n| description | 网站描述                                    |\n| author      | 您的名字                                    |\n| language    | 网站使用的语言                              |\n| timezone    | 网站时区（默认根据您当前时区而定，无需设置) |\n\n其中，`description`主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。`author`参数用于主题显示文章的作者。\n\n| 参数                 | 描述                                                         | 默认值                      |\n| -------------------- | ------------------------------------------------------------ | --------------------------- |\n| `url`                | 网址                                                         |                             |\n| `root`               | 网站根目录                                                   |                             |\n| `permalink`          | 文章的 [永久链接](https://hexo.io/zh-cn/docs/permalinks) 格式 | `:year/:month/:day/:title/` |\n| `permalink_defaults` | 永久链接中各部分的默认值                                     |                             |\n\n#### 网站存放在子目录\n\n如果您的网站存放在子目录中，例如 `http://yoursite.com/blog`，则请将您的 `url` 设为 `http://yoursite.com/blog` 并把 `root` 设为 `/blog/`。\n\n# 创建您的第一条博文\n\n您的所有博文源文件都在/source/_posts/中，都通过ｍｄ语法编写\n\n```\nhexo new \"这里写博文名\"\n```\n\n通过上面命令可以创造一个新的博文，您可以使用ｍｄ语法编写博文\n\n# 部署网站\n\n通过下面命令部署您的博客到http://localhost:4000\n\n```\nhexo server\n```\n\n# 生成博客静态文件\n\n如果您需要生成静态文件以上传到ｇｉｔｈｕｂ，您可以通过以下命令生成静态文件\n\n```\nhexo generate\n```\n\n生成的静态文件将会出现在publish文件夹内，您可以将ｐｕｂｌｉｓｈ文件夹内内容直接复制到ｇｉｔｈｕｂ。\n\n# FAQ\n\n目前仅发现一个常见问题：\n\n在 `_config.yml` 中\n\n如果您的网站存放在子目录中，例如 `http://yoursite.com/blog`，则请将您的 `url` 设为 `http://yoursite.com/blog` 并把 `root` 设为 `/blog/`。\n\n# 关于主题\n\n我使用的主题为hexo-casper，在github star 排行榜中挺靠前，中文文档链接　https://zhih.me/hexo-casper-usage/\n\n使用方法在文档中将会有呈现\n\n# 完成\n\n至此，您已完成博客构建，感谢观看。","tags":["踩坑记录"]},{"title":"Github踩坑记录","url":"/blog/2019/06/09/Github踩坑记录/","content":"我在手机上使用github的时候遇到了不少坑，当然最后都使用搜索引擎解决了，为了免得自己遗忘，特作此博文。\n\n## 开始使用\n\n我的手机没有root（主力机不敢root），所以我的git在sd卡目录中，并专门设立一个叫1024的文件夹放git，如果你们的目录不一样，可以随意修改。\n\n```\napt install git\napt install vim\napt install openssh\n```\n\n以上代码用于安装所需基本工具。\n\n## 建立git目录\n\n首先要设置你的邮箱和名字，应该是要和GitHub上设置的相同。\n\n```\ngit config --global user.name \"your name\"\ngit config --global user.email \"email@example.com\"\n```\n\n上面的命令引号内替换为自己的名字和邮箱 下一步建立git仓库的目录\n\n先cd到想要放git的目录\n\n我的目录是/sdcard/1024，所以要用命令：\n\n```\ncd /sdcard/1024\n```\n\n使用下面的指令，让这个文件夹变为git可以管理的仓库（这个文件夹一定要是空的）\n\n```\ngit init\n```\n\n这个指令使用成功后，文件夹下会多出来一个.git的文件夹\n\n## 上传文件到仓库\n\n下面我们上传文件到仓库 第一步，\n\n使用git add 如果只添加某个文件，\n\n如example.txt，则使用：\n\n```\ngit add example.txt\n```\n\n如果想把文件夹内文件全部添加（包括子文件夹），则使用：\n\n```\ngit add .\n```\n\n第二步，上传到本地仓库\n\n```\ngit commit -m \"这里写日志\"\n```\n\n引号内写日志，不可省略或不写！！！\n\n至此，关于git的大部分内容已讲完，如想了解更多git工作的教程，请访问网站：[廖雪峰的网站](https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013743858312764dca7ad6d0754f76aa562e3789478044000)，这是我找到的介绍比较全的网站\n\n## 上传到远程仓库\n\n首先通过ssh连接远程仓库，以GitHub为例。 \n\n我们已经安装了openssh，所以可以通过以下指令获取ssh代码：\n\n```\nssh-keygen -t rsa -C \"email@example.com\"\n```\n\n同样，引号内写邮箱 \n\n然后根据它的提示，找到id_rsa.pub文件所在目录，用vim打开\n\n```\nvim //后面加id_rsa.pub的文件地址\n```\n\nvim会打开这个文件，将里面所有代码复制出来即可。\n退出vim：确保自己没瞎jb按，然后输:q退出。\n\n然后打开GitHub，新建仓库，进入设置，打开ssh keys，新建，然后随便写一个标题，复制代码进去，点确认，OK。\n\n然后使用指令：\n\n```\ngit remote add origin https://github.com/lakphy/text.git\n```\n\n其中，lakphy是我的github名，text是仓库名，自己根据自己实际情况作修改。\n\n然后使用指令：\n\n```\ngit pull origin master\ngit push origin master\n```\n\n## 完成\n\n打开github即可看到代码已经上传成功了！","tags":["踩坑记录"]},{"title":"第一篇博文","url":"/blog/2019/06/09/第一篇博文/","content":"这里是第一篇博文","tags":["水博文"]}]